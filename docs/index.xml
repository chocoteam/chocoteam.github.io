<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Choco-solver – Documentation</title>
    <link>/docs/</link>
    <description>Recent content in Documentation on Choco-solver</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Declaring variables</title>
      <link>/docs/modeling/variables/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>/docs/modeling/variables/</guid>
      <description>
        
        
        &lt;p&gt;A variable is an &lt;em&gt;unknown&lt;/em&gt;, mathematically speaking.
The goal of a resolution is to &lt;em&gt;assign&lt;/em&gt; a &lt;em&gt;value&lt;/em&gt; to each variable.
The &lt;em&gt;domain&lt;/em&gt; of a variable –(super)set of values it may take– must be defined in the model.&lt;/p&gt;
&lt;p&gt;Choco-solver includes several types of variables: &lt;code&gt;BoolVar&lt;/code&gt;, &lt;code&gt;IntVar&lt;/code&gt;, &lt;code&gt;SetVar&lt;/code&gt; and &lt;code&gt;RealVar&lt;/code&gt;.
Variables are created using the &lt;code&gt;Model&lt;/code&gt; object.
When creating a variable, the user can specify a name to help reading the output.&lt;/p&gt;
&lt;h2 id=&#34;integer-variables&#34;&gt;Integer variables&lt;/h2&gt;
&lt;p&gt;An integer variable an unknown whose value should be an integer. Therefore, the domain of an integer variable is a set of integers (representing possible values).
To create an integer variable, the &lt;code&gt;Model&lt;/code&gt; should be used:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Create a constant variable equal to 42
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;v0&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v0&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Create a variable taking its value in [1, 3] (the value is 1, 2 or 3)
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;v1&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Create a variable taking its value in {1, 3} (the value is 1 or 3)
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;v2&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;It is then possible to build directly arrays and matrices of variables having the same initial domain with:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Create an array of 5 variables taking their value in [-1, 1]
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;vs&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVarArray&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;vs&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Create a matrix of 5x6 variables taking their value in [-1, 1]
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;vs&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVarMatrix&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;vs&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There exists different ways to encode the domain of an integer variable.&lt;/p&gt;
&lt;h3 id=&#34;bounded-domain&#34;&gt;Bounded domain&lt;/h3&gt;
&lt;p&gt;When the domain of an integer variable is said to be &lt;em&gt;bounded&lt;/em&gt;, it is represented through
an interval of the form $[\![a,b]\!]$ where $a$ and $b$ are integers such that $a \leq b$.
This representation is pretty light in memory (it requires only two integers) but it cannot represent &lt;em&gt;holes&lt;/em&gt; in the domain.
For instance, if we have a variable whose domain is $[\![0,10]\!]$ and a constraint enables to detect that
values 2, 3, 7 and 8 are infeasible, then this learning will be lost as it cannot be encoded in the domain (which remains the same).&lt;/p&gt;
&lt;p&gt;To specify you want to use bounded domains, set the &lt;code&gt;boundedDomain&lt;/code&gt; argument to &lt;code&gt;true&lt;/code&gt; when creating variables:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
When using bounded domains, branching decisions must either be domain splits or bound assignments/removals.
Indeed, assigning a bounded variable to a value strictly comprised between its bounds may results in infinite loop
because such branching decisions will not be refutable.
&lt;/div&gt;

&lt;h3 id=&#34;enumerated-domains&#34;&gt;Enumerated domains&lt;/h3&gt;
&lt;p&gt;When the domain of an integer variable is said to be &lt;em&gt;enumerated&lt;/em&gt;, it is represented through
the set of possible values, in the form:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[\![a,b]\!]$ where $a$ and $b$ are integers such that $a \leq b$&lt;/li&gt;
&lt;li&gt;${a,b,c,..,z}$, where $a &amp;lt; b &amp;lt; c &amp;hellip; &amp;lt; z$.
Enumerated domains provide more information than bounded domains but are heavier in memory (the domain usually requires a bitset).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To specify you want to use enumerated domains, either set the &lt;code&gt;boundedDomain&lt;/code&gt; argument to &lt;code&gt;false&lt;/code&gt; when creating variables by specifying two bounds
or use the signature that specifies the array of possible values:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;false&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;v&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;v&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;boolean-variable&#34;&gt;Boolean variable&lt;/h2&gt;
&lt;p&gt;Boolean variables, &lt;code&gt;BoolVar&lt;/code&gt;, are specific &lt;code&gt;IntVar&lt;/code&gt; that take their value in $[\![0,1]\!]$.
The avantage of &lt;code&gt;BoolVar&lt;/code&gt; is twofold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They can be used to say whether or not constraint should be satisfied (reification)&lt;/li&gt;
&lt;li&gt;Their domain, and some filtering algorithms, are optimized&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To create a new boolean variable:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;boolVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;b&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;set-variables&#34;&gt;Set variables&lt;/h2&gt;
&lt;p&gt;A set variable, &lt;code&gt;SetVar&lt;/code&gt;, represents a set of integers, i.e. its value is a set of integers.
Its domain is defined by a set interval $[\![m,o]\!]$ where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the lower bound, $m$, is an &lt;code&gt;ISet&lt;/code&gt; object which contains integers that figure in every solution.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the upper bound, $o$, is an &lt;code&gt;ISet&lt;/code&gt; object which contains integers that potentially figure in at least one solution,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Initial values for both $m$ and $o$ should be such that $m \subseteq o$.
Then, decisions and filtering algorithms will remove integers from $o$ and add some others to $m$.
A set variable is instantiated if and only if $m = o$.&lt;/p&gt;
&lt;p&gt;A set variable can be created as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// Constant SetVar equal to {2,3,12}
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SetVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;setVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// SetVar representing a subset of {1,2,3,5,12}
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SetVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;setVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;y&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// possible values: {}, {2}, {1,3,5} ...
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// SetVar representing a superset of {2,3} and a subset of {1,2,3,5,12}
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;SetVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;z&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;setVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;z&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;{&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;12&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// possible values: {2,3}, {2,3,5}, {1,2,3,5} ...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;real-variables&#34;&gt;Real variables&lt;/h2&gt;
&lt;p&gt;The domain of a real variable is an interval of doubles. Conceptually, the value of a real variable is a double.
However, it uses a precision parameter for floating number computation,
so its actual value is generally an interval of doubles, whose size is constrained by the precision parameter.
Real variables have a specific status in Choco 4, which uses &lt;a href=&#34;http://www.ibex-lib.org/&#34;&gt;Ibex solver&lt;/a&gt; to define constraints.&lt;/p&gt;
&lt;p&gt;A real variable is declared with three doubles defining its bound and a precision:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;RealVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;realVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;2d&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;4d&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;001d&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;views-creating-variables-from-constraints&#34;&gt;Views: Creating variables from constraints&lt;/h2&gt;
&lt;p&gt;When a variable is defined as a function of another variable, views can be
used to make the model shorter. In some cases, the view has a specific (optimized) domain representation.
Otherwise, it is simply a modeling shortcut to create a variable and post a constraint at the same time.&lt;/p&gt;
&lt;h3 id=&#34;arithmetical-views&#34;&gt;Arithmetical views&lt;/h3&gt;
&lt;p&gt;An arithmetical view requires an integer variable.&lt;/p&gt;
&lt;h4 id=&#34;x--y--2-&#34;&gt;$x = y + 2$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intOffsetView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;x---y-&#34;&gt;$x = -y$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intMinusView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;x--3times-y-&#34;&gt;$x = 3\times y$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intScaleView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;logical-views&#34;&gt;Logical views&lt;/h3&gt;
&lt;p&gt;A logical view is based on an integer variable, a basic arithmetical relation ($=,\neq,\leq,\geq$) and a constant. The resulting view states wether or not the relation holds.&lt;/p&gt;
&lt;h4 id=&#34;b-leftrightarrow-x--4-&#34;&gt;$b \Leftrightarrow (x = 4)$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intEqView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;b-leftrightarrow-x-neq-4-&#34;&gt;$b \Leftrightarrow (x \neq 4)$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intNeView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;b-leftrightarrow-x-leq-4-&#34;&gt;$b \Leftrightarrow (x \leq 4)$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intLeView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;b-leftrightarrow-x-geq-4-&#34;&gt;$b \Leftrightarrow (x \geq 4)$ :&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intGeView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;d-leftrightarrow-neg-b&#34;&gt;$d \Leftrightarrow \neg b$&lt;/h4&gt;
&lt;p&gt;This is a specific case, related to the negation of a &lt;code&gt;BoolVar&lt;/code&gt;.
No additional variable is needed, a view based on the variable to refute is enough.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;boolNotView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
&lt;p&gt;The same result can be obtained in shorted version:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;not&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;h3 id=&#34;composition&#34;&gt;Composition&lt;/h3&gt;
&lt;p&gt;Views can be combined together, e.g. $x = 2\times y + 5$ is:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intOffsetView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intScaleView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;view-over-real-variable&#34;&gt;View over real variable&lt;/h3&gt;
&lt;p&gt;We can also use a view mecanism to link an integer variable with a real variable.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;IntVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;ivar&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;intVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;i&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#204a87;font-weight:bold&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precision&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;001d&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;RealVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;rvar&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;realIntView&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;ivar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;precision&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This code enables to embed an integer variable in a constraint that is defined over real variables.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Handling constraints</title>
      <link>/docs/modeling/constraints/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:15 +0100</pubDate>
      
      <guid>/docs/modeling/constraints/</guid>
      <description>
        
        
        &lt;p&gt;A constraint is a logic formula defining allowed combinations of values for a set of variables,
i.e., restrictions over variables that must be respected in order to get a feasible solution.
A constraint is equipped with a (set of) filtering algorithm(s), named &lt;em&gt;propagator(s)&lt;/em&gt;.
A propagator &lt;strong&gt;removes&lt;/strong&gt;, from the domains of the target variables, values that cannot correspond to a valid combination of values.
A solution of a problem is variable-value assignment verifying all the constraints.&lt;/p&gt;
&lt;p&gt;Constraint can be declared in &lt;em&gt;extension&lt;/em&gt;, by defining the valid/invalid tuples, or in &lt;em&gt;intension&lt;/em&gt;, by defining a relation between the variables.
For a given requirement, there can be several constraints/propagators available.
A widely used example is the AllDifferent constraint which ensures that all its variables take a distinct value in a solution.
Such a rule can be formulated using :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a clique of basic inequality constraints,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a generic table constraint (an extension constraint that lists the valid tuples),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a dedicated global constraint analysing :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;instantiated variables (&lt;em&gt;Forward checking propagator&lt;/em&gt;),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variable domain bounds (&lt;em&gt;Bound consistency propagator&lt;/em&gt;),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variable domains (&lt;em&gt;Arc consistency propagator&lt;/em&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depending on the problem to solve, the efficiency of each option may be dramatically different.
In general, we tend to use global constraints, that capture a good part of the problem structure.
However, these constraints often model problems that are inherently NP-complete so only a partial filtering is performed
in general, to keep polynomial time algorithms.
This is for example the case of NValue constraint that one aspect relates to the problem of “minimum hitting set.”&lt;/p&gt;
&lt;h2 id=&#34;design-choices&#34;&gt;Design choices&lt;/h2&gt;
&lt;h3 id=&#34;class-organization&#34;&gt;Class organization&lt;/h3&gt;
&lt;p&gt;In Choco-solver, constraints are generally not associated with a specific java class.
Instead, each constraint is associated with a specific method in &lt;code&gt;Model&lt;/code&gt; that will build
a generic &lt;code&gt;Constraint&lt;/code&gt; with the right list of propagators.
Each propagator is associated with a unique java class.&lt;/p&gt;
&lt;p&gt;Note that it is not required to manipulate propagators, but only constraints.
However, one can define specific constraints by defining combinations of existing and/or its own propagators.&lt;/p&gt;
&lt;h3 id=&#34;solution-checking&#34;&gt;Solution checking&lt;/h3&gt;
&lt;p&gt;The satisfaction of the constraints is done on each solution by calling the &lt;code&gt;isSatisfied()&lt;/code&gt; method of every constraint.
By default, this method checks the &lt;code&gt;isEntailed()&lt;/code&gt; method of each of its propagators.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
Additional checks (Java assertions) can be performed by adding the &lt;code&gt;-ea&lt;/code&gt; instruction in the JVM arguments.
This is useful when debugging a program.
&lt;/div&gt;

&lt;h2 id=&#34;list-of-available-constraints&#34;&gt;List of available constraints&lt;/h2&gt;
&lt;p&gt;Please refer to the javadoc of &lt;code&gt;Model&lt;/code&gt; to have the complete list of available constraints.&lt;/p&gt;
&lt;h2 id=&#34;posting-constraints&#34;&gt;Posting constraints&lt;/h2&gt;
&lt;p&gt;To be effective, a constraint must be posted to the solver. This is achieved using the &lt;code&gt;post()&lt;/code&gt; method:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;allDifferent&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;vars&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;post&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Otherwise, if the &lt;code&gt;post()&lt;/code&gt; method is not called, the constraint will not be taken into account during the solution process :
it may not be satisfied in solutions.&lt;/p&gt;
&lt;h2 id=&#34;reifying-constraints&#34;&gt;Reifying constraints&lt;/h2&gt;
&lt;p&gt;In Choco-solver, it is possible to reify any constraint. Reifying a constraint means associating it with a &lt;code&gt;BoolVar&lt;/code&gt;
to represent whether or not the constraint is satisfied :&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;constraint&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;reify&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Or:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;boolVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;constraint&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;reifyWith&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Reifying a constraint means that we allow the constraint not to be satisfied.
Therefore, the reified constraint &lt;strong&gt;should not&lt;/strong&gt; be posted.
For instance, let us consider “if &lt;code&gt;x&amp;lt;0&lt;/code&gt; then &lt;code&gt;y&amp;gt;42&lt;/code&gt;”:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;ifThen&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;
   &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;arithm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;x&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;
   &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;arithm&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;y&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#4e9a06&#34;&gt;&amp;#34;&amp;gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;42&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;
&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Such constraint states that &lt;em&gt;if&lt;/em&gt; &lt;code&gt;x&lt;/code&gt; takes a value strictly less than &lt;code&gt;0&lt;/code&gt; &lt;em&gt;then&lt;/em&gt; &lt;code&gt;y&lt;/code&gt; should take a value stritctly greater than &lt;code&gt;42&lt;/code&gt;. Conversely, &lt;em&gt;if&lt;/em&gt; &lt;code&gt;x&lt;/code&gt; takes a value greater or equal to &lt;code&gt;0&lt;/code&gt; &lt;em&gt;then&lt;/em&gt; &lt;code&gt;y&lt;/code&gt; is not restricted.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
Reification is a specific process which does not rely on classical constraints.
This is why &lt;code&gt;ifThen&lt;/code&gt;, &lt;code&gt;ifThenElse&lt;/code&gt;, &lt;code&gt;ifOnlyIf&lt;/code&gt; and &lt;code&gt;reification&lt;/code&gt; return void and do not need to be posted.
&lt;/div&gt;



&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;
&lt;p&gt;A constraint is reified with only one boolean variable. Multiple calls to &lt;code&gt;constraint.reify()&lt;/code&gt; will return the same variable.
However, the following call will associate &lt;code&gt;b1&lt;/code&gt; with the constraint and then post &lt;code&gt;b1 = b2&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b1&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;boolVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;BoolVar&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b2&lt;/span&gt; &lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;boolVar&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;constraint&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;reifyWith&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b1&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#000&#34;&gt;constraint&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;reifyWith&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;b2&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: Constraints over integer variables</title>
      <link>/docs/modeling/intconstraints/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:15 +0100</pubDate>
      
      <guid>/docs/modeling/intconstraints/</guid>
      <description>
        
        
        &lt;h2 id=&#34;arithmetical-constraints&#34;&gt;Arithmetical constraints&lt;/h2&gt;
&lt;h2 id=&#34;cardinality-constraints&#34;&gt;Cardinality constraints&lt;/h2&gt;
&lt;h2 id=&#34;scheduling-constraints&#34;&gt;Scheduling constraints&lt;/h2&gt;
&lt;h2 id=&#34;table-constraints&#34;&gt;Table constraints&lt;/h2&gt;
&lt;h2 id=&#34;sat-constraints&#34;&gt;SAT constraints&lt;/h2&gt;
&lt;p&gt;A SAT solver is embedded in Choco-solver. It is not  designed to be accessed directly.
The SAT solver is internally managed as a constraint (and a propagator), that’s why it is referred to as SAT constraint in the following.&lt;/p&gt;
&lt;p&gt;Clauses can be added with the &lt;code&gt;Model&lt;/code&gt; thanks to methods whose name begins with &lt;code&gt;addClause*&lt;/code&gt;.
There exists two type of clauses declaration: pre-defined ones (such as &lt;code&gt;addClausesBoolLt&lt;/code&gt; or &lt;code&gt;addClausesAtMostNMinusOne&lt;/code&gt;) or more free ones by specifying a &lt;code&gt;LogOp&lt;/code&gt; that represents a clause expression:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;addClauses&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LogOp&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;and&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LogOp&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;nand&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;LogOp&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;nor&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;LogOp&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;or&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;// with static import of LogOp
&lt;/span&gt;&lt;span style=&#34;color:#8f5902;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;model&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#c4a000&#34;&gt;addClauses&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;and&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;nand&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;nor&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;or&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#000&#34;&gt;c&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#000&#34;&gt;e&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#ce5c00;font-weight:bold&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;automaton-based-constraints&#34;&gt;Automaton-based Constraints&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;regular&lt;/code&gt;, &lt;code&gt;costRegular&lt;/code&gt; and &lt;code&gt;multiCostRegular&lt;/code&gt; rely on an automaton, declared either implicitly or explicitly.
There are two kinds of &lt;code&gt;IAutomaton&lt;/code&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FiniteAutomaton&lt;/code&gt;, needed for &lt;code&gt;regular&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CostAutomaton&lt;/code&gt;, required for &lt;code&gt;costRegular&lt;/code&gt; and &lt;code&gt;multiCostRegular&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;FiniteAutomaton&lt;/code&gt; embeds an &lt;code&gt;Automaton&lt;/code&gt; object provided by the &lt;code&gt;dk.brics.automaton&lt;/code&gt; library.
Such an automaton accepts fixed-size words made of multiple &lt;code&gt;char&lt;/code&gt;, but the regular constraints rely on &lt;code&gt;IntVar&lt;/code&gt;,
so a mapping between &lt;code&gt;char&lt;/code&gt; (needed by the underlying library) and &lt;code&gt;int&lt;/code&gt; (declared in &lt;code&gt;IntVar&lt;/code&gt;) has been made.
The mapping enables declaring regular expressions where a symbol is not only a digit between 0 and 9 but any &lt;strong&gt;positive&lt;/strong&gt; number.
Then to distinct, in the word 101, the symbols 0, 1, 10 and 101, two additional &lt;code&gt;char&lt;/code&gt; are allowed in a regexp: &amp;lt; and &amp;gt; which delimits numbers.&lt;/p&gt;
&lt;p&gt;In summary, a valid regexp for the automaton-based constraints is a combination of &lt;strong&gt;digits&lt;/strong&gt; and Java Regexp special characters.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CostAutomaton&lt;/code&gt; is an extension of &lt;code&gt;FiniteAutomaton&lt;/code&gt; where costs can be declared for each transition.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Constraints over set variables</title>
      <link>/docs/modeling/setconstraints/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:15 +0100</pubDate>
      
      <guid>/docs/modeling/setconstraints/</guid>
      <description>
        
        
        &lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Constraints over real variables</title>
      <link>/docs/modeling/realconstraints/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:15 +0100</pubDate>
      
      <guid>/docs/modeling/realconstraints/</guid>
      <description>
        
        
        &lt;h2 id=&#34;todo&#34;&gt;TODO&lt;/h2&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Building expressions</title>
      <link>/docs/modeling/expressions/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:23 +0100</pubDate>
      
      <guid>/docs/modeling/expressions/</guid>
      <description>
        
        
        &lt;p&gt;Text can be &lt;strong&gt;bold&lt;/strong&gt;, &lt;em&gt;italic&lt;/em&gt;, or &lt;del&gt;strikethrough&lt;/del&gt;. &lt;a href=&#34;https://gohugo.io&#34;&gt;Links&lt;/a&gt; should be blue with no underlines (unless hovered over).&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Exploring search space</title>
      <link>/docs/solving/strategies/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>/docs/solving/strategies/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: Looking for solutions</title>
      <link>/docs/solving/solving/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>/docs/solving/solving/</guid>
      <description>
        
        
        &lt;p&gt;Up to here, we have seen how to model a problem with the &lt;code&gt;Model&lt;/code&gt; object. To solve it, we need to use
the &lt;code&gt;Solver&lt;/code&gt; object that is obtained from the model as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver solver = model.getSolver();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;Solver&lt;/code&gt; is in charge of alternating constraint-propagation with search, and possibly learning,
in order to compute solutions. This object may be configured in various ways.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Designing a propagator</title>
      <link>/docs/advanced-usages/propagator/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:15 +0100</pubDate>
      
      <guid>/docs/advanced-usages/propagator/</guid>
      <description>
        
        
        &lt;h3 id=&#34;designing-your-own-constraint&#34;&gt;Designing your own constraint&lt;/h3&gt;
&lt;p&gt;You can create your own constraint by creating a generic &lt;code&gt;Constraint&lt;/code&gt; object with the appropriate propagator:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constraint c = new Constraint(&amp;quot;MyConstraint&amp;quot;, new MyPropagator(vars));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The only tricky part relies in the propagator implementation.
Your propagator must extend the &lt;code&gt;Propagator&lt;/code&gt; class but, at the begining, not all methods have to be overwritted.
We will see two ways to implement a propagator ensuring that &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;basic-propagator&#34;&gt;Basic propagator&lt;/h4&gt;
&lt;p&gt;You must at least call the super constructor to specifies the scope (set of variables) of the propagator.
Then you must implement the two following methods:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void propagate(int evtmask)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method applies the global filtering algorithm of the propagator, that is, from &lt;em&gt;scratch&lt;/em&gt;.
It is called once during initial propagation (to propagate initial domains) and then during the solving process if
the propagator is not incremental. It is the most important method of the propagator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;isEntailed()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method checks the current state of the propagator. It is used for constraint reification.
It checks whether the propagator will be always satisfied (&lt;code&gt;ESat.TRUE&lt;/code&gt;), never satisfied (&lt;code&gt;ESat.FALSE&lt;/code&gt;)
or undefined (&lt;code&gt;ESat.UNDEFINED&lt;/code&gt;) according to the current state of its domain variables. For instance,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A \neq B$ will always be satisfied when $A={0,1,2}$ and $B={4,5}$.&lt;/li&gt;
&lt;li&gt;$A = B$ will never be satisfied when $A={0,1,2}$ and $B={4,5}$.&lt;/li&gt;
&lt;li&gt;The entailment of $A \neq B$ cannot be defined when $A={0,1,2}$ and $B={1,2,3}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ESat isEntailed()&lt;/code&gt; implementation may be approximate
but should at least cover the case where all variables are instantiated, in order to check solutions.&lt;/p&gt;
&lt;p&gt;Here is an example of how to implement a propagator for &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Propagator to apply X &amp;gt;= Y
public class MySimplePropagator extends Propagator&amp;lt;IntVar&amp;gt; {

    IntVar x, y;

    public MySimplePropagator(IntVar x, IntVar y) {
        super(new IntVar[]{x,y});
        this.x = x;
        this.y = y;
    }

    @Override
    public void propagate(int evtmask) throws ContradictionException {
        x.updateLowerBound(y.getLB(), this);
        y.updateUpperBound(x.getUB(), this);
    }

    @Override
    public ESat isEntailed() {
        if (x.getUB() &amp;lt; y.getLB())
            return ESat.FALSE;
        else if (x.getLB() &amp;gt;= y.getUB())
            return ESat.TRUE;
        else
            return ESat.UNDEFINED;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;elaborated-propagator&#34;&gt;Elaborated propagator&lt;/h4&gt;
&lt;p&gt;The super constructor &lt;code&gt;super(Variable[], PropagatorPriority, boolean);&lt;/code&gt; brings more information.
&lt;code&gt;PropagatorPriority&lt;/code&gt; enables to optimize the propagation engine (low arity for fast propagators is better).
The boolean argument allows to specifies the propagator is incremental.
When set to &lt;code&gt;true&lt;/code&gt;, the method &lt;code&gt;propagate(int varIdx, int mask)&lt;/code&gt; must be implemented.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Note that if many variables are modified between two calls, a non-incremental filtering may be faster (and simpler).&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;propagate(int varIdx, int mask)&lt;/code&gt; defines the incremental filtering.
It is called for every variable &lt;code&gt;vars[varIdx]&lt;/code&gt; whose domain has changed since the last call.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;getPropagationConditions(int vIdx)&lt;/code&gt; enables not to react on every kind of domain modification.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;setPassive()&lt;/code&gt; enables to desactivate the propagator when it is entailed, to save time.
The propagator is automatically reactivated upon backtrack.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;why(...)&lt;/code&gt; explains the filtering, to allow learning.&lt;/p&gt;
&lt;p&gt;Here is an example of how to implement a propagator for &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Propagator to apply X &amp;gt;= Y
public final class MyIncrementalPropagator extends Propagator&amp;lt;IntVar&amp;gt; {

    IntVar x, y;

    public MyIncrementalPropagator(IntVar x, IntVar y) {
        super(new IntVar[]{x,y}, PropagatorPriority.BINARY, true);
        this.x = x;
        this.y = y;
    }

    @Override
    public int getPropagationConditions(int vIdx) {
        if (vIdx == 0) {
            // awakes if x gets instantiated or if its upper bound decreases
            return IntEventType.combine(IntEventType.INSTANTIATE, IntEventType.DECUPP);
        } else {
            // awakes if y gets instantiated or if its lower bound increases
            return IntEventType.combine(IntEventType.INSTANTIATE, IntEventType.INCLOW);
        }
    }

    @Override
    public void propagate(int evtmask) throws ContradictionException {
        x.updateLowerBound(y.getLB(), this);
        y.updateUpperBound(x.getUB(), this);
        if (x.getLB() &amp;gt;= y.getUB()) {
            this.setPassive();
        }
    }

    @Override
    public void propagate(int varIdx, int mask) throws ContradictionException {
        if (varIdx == 0) {
            y.updateUpperBound(x.getUB(), this);
        } else {
            x.updateLowerBound(y.getLB(), this);
        }
        if (x.getLB() &amp;gt;= y.getUB()) {
            this.setPassive();
        }
    }

    @Override
    public ESat isEntailed() {
        if (x.getUB() &amp;lt; y.getLB())
            return ESat.FALSE;
        else if (x.getLB() &amp;gt;= y.getUB())
            return ESat.TRUE;
        else
            return ESat.UNDEFINED;
    }

    @Override
    public boolean why(RuleStore ruleStore, IntVar var, IEventType evt, int value) {
        boolean newrules = ruleStore.addPropagatorActivationRule(this);
        if (var.equals(x)) {
            newrules |=ruleStore.addLowerBoundRule(y);
        } else if (var.equals(y)) {
            newrules |=ruleStore.addUpperBoundRule(x);
        } else {
            newrules |=super.why(ruleStore, var, evt, value);
        }
        return newrules;
    }

    @Override
    public String toString() {
        return &amp;quot;prop(&amp;quot; + vars[0].getName() + &amp;quot;.GEQ.&amp;quot; + vars[1].getName() + &amp;quot;)&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;idempotency&#34;&gt;Idempotency&lt;/h3&gt;
&lt;p&gt;We distinguish two kinds of propagators:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Necessary&lt;/em&gt; propagators, which ensure constraints to be satisfied.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Redundant&lt;/em&gt; (or &lt;em&gt;Implied&lt;/em&gt;) propagators that come in addition to some necessary propagators in order to get a stronger filtering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some propagators cannot be idempotent (Lagrangian relaxation, use of randomness, etc.).
For some others, forcing idempotency may be very time consuming.
A redundant propagator does not have to be idempotent but &lt;strong&gt;a necessary propagator should be idempotent&lt;/strong&gt;  .&lt;/p&gt;
&lt;p&gt;Trying to make a propagator idempotent directly may not be straightforward.
We provide three implementation possibilities.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;decomposed&lt;/em&gt;  (recommended) option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Split the original propagator into (partial) propagators so that the fix point is performed through the propagation engine.
For instance, a channeling propagator $A \Leftrightarrow B$ can be decomposed into two propagators $A \Rightarrow B$ and $B \Rightarrow A$.
The propagators can (but do not have to) react on fine events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;lazy&lt;/em&gt; option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Simply post the propagator twice.
Thus, the fix point is performed through the propagation engine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;coarse&lt;/em&gt; option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the propagator will perform its fix point by itself.
The propagator does not react to fine events.
The coarse filtering algorithm should be surrounded like this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;// In the case of ``SetVar``, replace ``getDomSize()`` by ``getEnvSize()-getKerSize()``.
long size;
do{
  size = 0;
  for(IntVar v:vars){
    size+=v.getDomSize();
  }
  // really update domain variables here
  for(IntVar v:vars){
    size-=v.getDomSize();
  }
}while(size&amp;gt;0);
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Domain variable modifier returns a boolean valued to &lt;code&gt;true&lt;/code&gt; if the domain variable has been modified.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: </title>
      <link>/docs/advanced-usages/to-remove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/advanced-usages/to-remove/</guid>
      <description>
        
        
        &lt;h1 id=&#34;miscellaneous&#34;&gt;Miscellaneous&lt;/h1&gt;
&lt;h2 id=&#34;settings&#34;&gt;Settings&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Settings&lt;/code&gt; object is attached to each &lt;code&gt;Model&lt;/code&gt;.
It declares default behavior for various purposes: from general purpose (such as the welcome message), modelling purpose (such as enabling views) or solving purpose (such as the search binder).&lt;/p&gt;
&lt;p&gt;Default settings can be accessed through &lt;code&gt;DefaultSettings&lt;/code&gt;.
This class can be extended to provide more settings and set to modified the default values.&lt;/p&gt;
&lt;p&gt;Settings are declared in a &lt;code&gt;Model&lt;/code&gt; constructor.
Settings are not immutable but modifying value after &lt;code&gt;Model&lt;/code&gt; construction can lead to unexpected behavior.&lt;/p&gt;
&lt;h2 id=&#34;extensions-of-choco&#34;&gt;Extensions of Choco&lt;/h2&gt;
&lt;h3 id=&#34;choco-parsers&#34;&gt;choco-parsers&lt;/h3&gt;
&lt;p&gt;choco-parsers is an extension of Choco 4. It provides a parser for the FlatZinc language, a low-level solver input language that is the target language for MiniZinc.
This module follows the flatzinc standards that are used for the annual MiniZinc challenge. It only supports integer variables.
You will find it at &lt;a href=&#34;https://github.com/chocoteam/choco-parsers&#34;&gt;https://github.com/chocoteam/choco-parsers&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;choco-graph&#34;&gt;choco-graph&lt;/h3&gt;
&lt;p&gt;choco-graph is a Choco 4 module which allows to search for a graph, which may be subject to graph constraints.
The domain of a graph variable G is a graph interval in the form [G_lb,G_ub].
G_lb is the graph representing vertices and edges which must belong to any single solution whereas G_ub is the graph representing vertices and edges which may belong to one solution.
Therefore, any value G_v must satisfy the graph inclusion “G_lb subgraph of G_v subgraph of  G_ub”.
One may see a strong connection with set variables.
A graph variable can be subject to graph constraints to ensure global graph properties (e.g. connectedness, acyclicity) and channeling constraints to link the graph variable with some other binary, integer or set variables.
The solving process consists of removing nodes and edges from G_ub and adding some others to G_lb until having G_lb = G_ub, i.e. until G gets instantiated.
These operations stem from both constraint propagation and search. The benefits of graph variables stem from modeling convenience and performance.&lt;/p&gt;
&lt;p&gt;This extension has documentation. You will find it at &lt;a href=&#34;https://github.com/chocoteam/choco-graph&#34;&gt;https://github.com/chocoteam/choco-graph&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;choco-gui&#34;&gt;choco-gui&lt;/h3&gt;
&lt;p&gt;choco-gui is an extension of Choco 4.
It provides a Graphical User Interface with various views which can be simply plugged on any Choco Model object.
You will find it at &lt;a href=&#34;https://github.com/chocoteam/choco-gui&#34;&gt;https://github.com/chocoteam/choco-gui&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;ibex-solver&#34;&gt;Ibex Solver&lt;/h2&gt;
&lt;p&gt;To manage continuous constraints with Choco, an interface with Ibex has been done.
It needs Ibex to be installed on your system.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“IBEX is a C++ library for constraint processing over real numbers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;It provides reliable algorithms for handling non-linear constraints.
In particular, round off errors are also taken into account.
It is based on interval arithmetic and affine arithmetic.”
– &lt;a href=&#34;http://www.ibex-lib.org/&#34;&gt;http://www.ibex-lib.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;installing-ibex&#34;&gt;Installing Ibex&lt;/h3&gt;
&lt;p&gt;See the &lt;a href=&#34;http://www.ibex-lib.org/doc/install.html&#34;&gt;installation instructions&lt;/a&gt; of Ibex to complied Ibex on your system.
More specially, take a look at &lt;a href=&#34;http://www.ibex-lib.org/doc/install.html#installation-as-a-dynamic-library&#34;&gt;Installation as a dynamic library&lt;/a&gt;
Do not forget to add the &lt;code&gt;--with-java-package=org.chocosolver.solver.constraints.real&lt;/code&gt; configuration option.&lt;/p&gt;
&lt;h3 id=&#34;using-ibex&#34;&gt;Using Ibex&lt;/h3&gt;
&lt;p&gt;Once the installation is completed, the JVM needs to know where Ibex is installed to fully benefit from the Choco-Ibex bridge and declare real variables and constraints.
This can be done either with an environment variable of by adding &lt;code&gt;-Djava.library.path=path/to/ibex/lib&lt;/code&gt; to the JVM arguments.
The path /path/to/ibex/lib points to the lib directory of the Ibex installation directory.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: </title>
      <link>/docs/modeling/to-remove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/modeling/to-remove/</guid>
      <description>
        
        
        &lt;h1 id=&#34;modeling&#34;&gt;Modeling&lt;/h1&gt;
&lt;h2 id=&#34;the-model&#34;&gt;The Model&lt;/h2&gt;
&lt;p&gt;The object &lt;code&gt;Model&lt;/code&gt; is the key component. It is built as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Model model = new Model();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;or:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Model model = new Model(&amp;quot;my problem&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This should be the first instruction, prior to any other modeling instructions, as it is needed to declare variables and constraints.&lt;/p&gt;
&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;
&lt;h3 id=&#34;principle&#34;&gt;Principle&lt;/h3&gt;
&lt;p&gt;A variable is an &lt;em&gt;unknown&lt;/em&gt;, mathematically speaking.
The goal of a resolution is to &lt;em&gt;assign&lt;/em&gt; a &lt;em&gt;value&lt;/em&gt; to each variable.
The &lt;em&gt;domain&lt;/em&gt; of a variable –(super)set of values it may take– must be defined in the model.&lt;/p&gt;
&lt;p&gt;Choco 4 includes several types of variables: &lt;code&gt;BoolVar&lt;/code&gt;, &lt;code&gt;IntVar&lt;/code&gt;, &lt;code&gt;SetVar&lt;/code&gt; and &lt;code&gt;RealVar&lt;/code&gt;.
Variables are created using the &lt;code&gt;Model&lt;/code&gt; object.
When creating a variable, the user can specify a name to help reading the output.&lt;/p&gt;
&lt;h3 id=&#34;integer-variables&#34;&gt;Integer variables&lt;/h3&gt;
&lt;p&gt;An integer variable an unknown whose value should be an integer. Therefore, the domain of an integer variable is a set of integers (representing possible values).
To create an integer variable, the &lt;code&gt;Model&lt;/code&gt; should be used:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Create a constant variable equal to 42
IntVar v0 = model.intVar(&amp;quot;v0&amp;quot;, 42);
// Create a variable taking its value in [1, 3] (the value is 1, 2 or 3)
IntVar v1 = model.intVar(&amp;quot;v1&amp;quot;, 1, 3);
// Create a variable taking its value in {1, 3} (the value is 1 or 3)
IntVar v2 = model.intVar(&amp;quot;v2&amp;quot;, new int[]{1, 3});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is then possible to build directly arrays and matrices of variables having the same initial domain with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Create an array of 5 variables taking their value in [-1, 1]
IntVar[] vs = model.intVarArray(&amp;quot;vs&amp;quot;, 5, -1, 1);
// Create a matrix of 5x6 variables taking their value in [-1, 1]
IntVar[][] vs = model.intVarMatrix(&amp;quot;vs&amp;quot;, 5, 6, -1, 1);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There exists different ways to encode the domain of an integer variable.&lt;/p&gt;
&lt;h4 id=&#34;bounded-domain&#34;&gt;Bounded domain&lt;/h4&gt;
&lt;p&gt;When the domain of an integer variable is said to be &lt;em&gt;bounded&lt;/em&gt;, it is represented through
an interval of the form $[![a,b]!]$ where $a$ and $b$ are integers such that $a &amp;lt;= b$.
This representation is pretty light in memory (it requires only two integers) but it cannot represent &lt;em&gt;holes&lt;/em&gt; in the domain.
For instance, if we have a variable whose domain is $[![0,10]!]$ and a constraint enables to detect that
values 2, 3, 7 and 8 are infeasible, then this learning will be lost as it cannot be encoded in the domain (which remains the same).&lt;/p&gt;
&lt;p&gt;To specify you want to use bounded domains, set the &lt;code&gt;boundedDomain&lt;/code&gt; argument to &lt;code&gt;true&lt;/code&gt; when creating variables:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar v = model.intVar(&amp;quot;v&amp;quot;, 1, 12, true);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: When using bounded domains, branching decisions must either be domain splits or bound assignments/removals.
Indeed, assigning a bounded variable to a value strictly comprised between its bounds may results in infinite loop
because such branching decisions will not be refutable.&lt;/p&gt;
&lt;h4 id=&#34;enumerated-domains&#34;&gt;Enumerated domains&lt;/h4&gt;
&lt;p&gt;When the domain of an integer variable is said to be &lt;em&gt;enumerated&lt;/em&gt;, it is represented through
the set of possible values, in the form:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$[![a,b]!]$ where $a$ and $b$ are integers such that $a &amp;lt;= b$&lt;/li&gt;
&lt;li&gt;{$a,b,c,..,z$}, where $a &amp;lt; b &amp;lt; c &amp;hellip; &amp;lt; z$.
Enumerated domains provide more information than bounded domains but are heavier in memory (the domain usually requires a bitset).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To specify you want to use enumerated domains, either set the &lt;code&gt;boundedDomain&lt;/code&gt; argument to &lt;code&gt;false&lt;/code&gt; when creating variables by specifying two bounds
or use the signature that specifies the array of possible values:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar v = model.intVar(&amp;quot;v&amp;quot;, 1, 4, false);
IntVar v = model.intVar(&amp;quot;v&amp;quot;, new int[]{1,2,3,4});
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;boolean-variable&#34;&gt;Boolean variable&lt;/h3&gt;
&lt;p&gt;Boolean variables, &lt;code&gt;BoolVar&lt;/code&gt;, are specific &lt;code&gt;IntVar&lt;/code&gt; that take their value in $[![0,1]!]$.
The avantage of &lt;code&gt;BoolVar&lt;/code&gt; is twofold:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They can be used to say whether or not constraint should be satisfied (reification)&lt;/li&gt;
&lt;li&gt;Their domain, and some filtering algorithms, are optimized&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To create a new boolean variable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BoolVar b = model.boolVar(&amp;quot;b&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;set-variables&#34;&gt;Set variables&lt;/h3&gt;
&lt;p&gt;A set variable, &lt;code&gt;SetVar&lt;/code&gt;, represents a set of integers, i.e. its value is a set of integers.
Its domain is defined by a set interval &lt;code&gt;[LB,UB]&lt;/code&gt; where:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the lower bound, &lt;code&gt;LB&lt;/code&gt;, is an &lt;code&gt;ISet&lt;/code&gt; object which contains integers that figure in every solution.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the upper bound, &lt;code&gt;UB&lt;/code&gt;, is an &lt;code&gt;ISet&lt;/code&gt; object which contains integers that potentially figure in at least one solution,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Initial values for both &lt;code&gt;LB&lt;/code&gt; and &lt;code&gt;UB&lt;/code&gt; should be such that &lt;code&gt;LB&lt;/code&gt; is a subset of &lt;code&gt;UB&lt;/code&gt;.
Then, decisions and filtering algorithms will remove integers from &lt;code&gt;UB&lt;/code&gt; and add some others to &lt;code&gt;LB&lt;/code&gt;.
A set variable is instantiated if and only if &lt;code&gt;LB = UB&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A set variable can be created as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Constant SetVar equal to {2,3,12}
SetVar x = model.setVar(&amp;quot;x&amp;quot;, new int[]{2,3,12});

// SetVar representing a subset of {1,2,3,5,12}
SetVar y = model.setVar(&amp;quot;y&amp;quot;, new int[]{}, new int[]{1,2,3,5,12});
// possible values: {}, {2}, {1,3,5} ...

// SetVar representing a superset of {2,3} and a subset of {1,2,3,5,12}
SetVar z = model.setVar(&amp;quot;z&amp;quot;, new int[]{2,3}, new int[]{1,2,3,5,12});
// possible values: {2,3}, {2,3,5}, {1,2,3,5} ...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;real-variables&#34;&gt;Real variables&lt;/h3&gt;
&lt;p&gt;The domain of a real variable is an interval of doubles. Conceptually, the value of a real variable is a double.
However, it uses a precision parameter for floating number computation,
so its actual value is generally an interval of doubles, whose size is constrained by the precision parameter.
Real variables have a specific status in Choco 4, which uses &lt;a href=&#34;http://www.ibex-lib.org/&#34;&gt;Ibex solver&lt;/a&gt; to define constraints.&lt;/p&gt;
&lt;p&gt;A real variable is declared with three doubles defining its bound and a precision:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RealVar x = model.realVar(&amp;quot;x&amp;quot;, 0.2d, 3.4d, 0.001d);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;views-creating-variables-from-constraints&#34;&gt;Views: Creating variables from constraints&lt;/h3&gt;
&lt;p&gt;When a variable is defined as a function of another variable, views can be
used to make the model shorter. In some cases, the view has a specific (optimized) domain representation.
Otherwise, it is simply a modeling shortcut to create a variable and post a constraint at the same time.
Few examples:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;x = y + 2&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar x = model.intOffsetView(y, 2);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;x = -y&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar x = model.intMinusView(y);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;x = 3\*y&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar x = model.intScaleView(y, 3);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Views can be combined together, e.g. &lt;code&gt;x = 2\*y + 5&lt;/code&gt; is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar x = model.intOffsetView(model.intScaleView(y,2),5);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can also use a view mecanism to link an integer variable with a real variable.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IntVar ivar = model.intVar(&amp;quot;i&amp;quot;, 0, 4);
double precision = 0.001d;
RealVar rvar = model.realIntView(ivar, precision);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code enables to embed an integer variable in a constraint that is defined over real variables.&lt;/p&gt;
&lt;h2 id=&#34;constraints&#34;&gt;Constraints&lt;/h2&gt;
&lt;h3 id=&#34;constraints-and-propagators&#34;&gt;Constraints and propagators&lt;/h3&gt;
&lt;h4 id=&#34;main-principles&#34;&gt;Main principles&lt;/h4&gt;
&lt;p&gt;A constraint is a logic formula defining allowed combinations of values for a set of variables,
i.e., restrictions over variables that must be respected in order to get a feasible solution.
A constraint is equipped with a (set of) filtering algorithm(s), named &lt;em&gt;propagator(s)&lt;/em&gt;.
A propagator &lt;strong&gt;removes&lt;/strong&gt;, from the domains of the target variables, values that cannot correspond to a valid combination of values.
A solution of a problem is variable-value assignment verifying all the constraints.&lt;/p&gt;
&lt;p&gt;Constraint can be declared in &lt;em&gt;extension&lt;/em&gt;, by defining the valid/invalid tuples, or in &lt;em&gt;intension&lt;/em&gt;, by defining a relation between the variables.
For a given requirement, there can be several constraints/propagators available.
A widely used example is the AllDifferent constraint which ensures that all its variables take a distinct value in a solution.
Such a rule can be formulated using :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a clique of basic inequality constraints,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a generic table constraint (an extension constraint that lists the valid tuples),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a dedicated global constraint analysing :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;instantiated variables (&lt;em&gt;Forward checking propagator&lt;/em&gt;),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variable domain bounds (&lt;em&gt;Bound consistency propagator&lt;/em&gt;),&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;variable domains (&lt;em&gt;Arc consistency propagator&lt;/em&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Depending on the problem to solve, the efficiency of each option may be dramatically different.
In general, we tend to use global constraints, that capture a good part of the problem structure.
However, these constraints often model problems that are inherently NP-complete so only a partial filtering is performed
in general, to keep polynomial time algorithms.
This is for example the case of NValue constraint that one aspect relates to the problem of “minimum hitting set.”&lt;/p&gt;
&lt;h4 id=&#34;design-choices&#34;&gt;Design choices&lt;/h4&gt;
&lt;h5 id=&#34;class-organization&#34;&gt;Class organization&lt;/h5&gt;
&lt;p&gt;In Choco Solver 4, constraints are generally not associated with a specific java class.
Instead, each constraint is associated with a specific method in &lt;code&gt;Model&lt;/code&gt; that will build
a generic &lt;code&gt;Constraint&lt;/code&gt; with the right list of propagators.
Each propagator is associated with a unique java class.&lt;/p&gt;
&lt;p&gt;Note that it is not required to manipulate propagators, but only constraints.
However, one can define specific constraints by defining combinations of existing and/or its own propagators.&lt;/p&gt;
&lt;h5 id=&#34;solution-checking&#34;&gt;Solution checking&lt;/h5&gt;
&lt;p&gt;The satisfaction of the constraints is done on each solution by calling the &lt;code&gt;isSatisfied()&lt;/code&gt; method of every constraint.
By default, this method checks the &lt;code&gt;isEntailed()&lt;/code&gt; method of each of its propagators.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Additional checks (Java assertions) can be performed by adding the &lt;code&gt;-ea&lt;/code&gt; instruction in the JVM arguments.
This is useful when debugging a program.&lt;/p&gt;
&lt;h3 id=&#34;list-of-available-constraints&#34;&gt;List of available constraints&lt;/h3&gt;
&lt;p&gt;Please refer to the javadoc of &lt;code&gt;Model&lt;/code&gt; to have the list of available constraints.&lt;/p&gt;
&lt;h3 id=&#34;posting-constraints&#34;&gt;Posting constraints&lt;/h3&gt;
&lt;p&gt;To be effective, a constraint must be posted to the solver. This is achieved using the &lt;code&gt;post()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;model.allDifferent(vars).post();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Otherwise, if the &lt;code&gt;post()&lt;/code&gt; method is not called, the constraint will not be taken into account during the solution process :
it may not be satisfied in solutions.&lt;/p&gt;
&lt;h3 id=&#34;reifying-constraints&#34;&gt;Reifying constraints&lt;/h3&gt;
&lt;p&gt;In Choco 4, it is possible to reify any constraint. Reifying a constraint means associating it with a &lt;code&gt;BoolVar&lt;/code&gt;
to represent whether or not the constraint is satisfied :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BoolVar b = constraint.reify();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BoolVar b = model.boolVar();
constraint.reifyWith(b);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Reifying a constraint means that we allow the constraint not to be satisfied.
Therefore, the reified constraint &lt;strong&gt;should not&lt;/strong&gt; be posted.
For instance, let us consider “if &lt;code&gt;x&amp;lt;0&lt;/code&gt; then &lt;code&gt;y&amp;gt;42&lt;/code&gt;”:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;model.ifThen(
   model.arithm(x,&amp;quot;&amp;lt;&amp;quot;,0),
   model.arithm(y,&amp;quot;&amp;gt;&amp;quot;,42)
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Reification is a specific process which does not rely on classical constraints.
This is why &lt;code&gt;ifThen&lt;/code&gt;, &lt;code&gt;ifThenElse&lt;/code&gt;, &lt;code&gt;ifOnlyIf&lt;/code&gt; and &lt;code&gt;reification&lt;/code&gt; return void and do not need to be posted.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: A constraint is reified with only one boolean variable. Multiple calls to &lt;code&gt;constraint.reify()&lt;/code&gt; will return the same variable.
However, the following call will associate &lt;code&gt;b1&lt;/code&gt; with the constraint and then post &lt;code&gt;b1 = b2&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;BoolVar b1 = model.boolVar();
BoolVar b2 = model.boolVar();
constraint.reifyWith(b1);
constraint.reifyWith(b2);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;some-specific-constraints&#34;&gt;Some specific constraints&lt;/h3&gt;
&lt;h4 id=&#34;sat-constraints&#34;&gt;SAT constraints&lt;/h4&gt;
&lt;p&gt;A SAT solver is embedded in Choco. It is not  designed to be accessed directly.
The SAT solver is internally managed as a constraint (and a propagator), that’s why it is referred to as SAT constraint in the following.&lt;/p&gt;
&lt;p&gt;Clauses can be added with the &lt;code&gt;SatFactory&lt;/code&gt; (refer to javadoc for details).
On any call to a method of &lt;code&gt;SatFactory&lt;/code&gt;, the SAT constraint (and its propagator) is created and automatically posted to the solver.
To declare complex clauses, you can call &lt;code&gt;SatFactory.addClauses(...)&lt;/code&gt; by specifying a &lt;code&gt;LogOp&lt;/code&gt; that represents a clause expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SatFactory.addClauses(LogOp.and(LogOp.nand(LogOp.nor(a, b), LogOp.or(c, d)), e), model);
// with static import of LogOp
SatFactory.addClauses(and(nand(nor(a, b), or(c, d)), e), model);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;automaton-based-constraints&#34;&gt;Automaton-based Constraints&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;regular&lt;/code&gt;, &lt;code&gt;costRegular&lt;/code&gt; and &lt;code&gt;multiCostRegular&lt;/code&gt; rely on an automaton, declared either implicitly or explicitly.
There are two kinds of &lt;code&gt;IAutomaton&lt;/code&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FiniteAutomaton&lt;/code&gt;, needed for &lt;code&gt;regular&lt;/code&gt;,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CostAutomaton&lt;/code&gt;, required for &lt;code&gt;costRegular&lt;/code&gt; and &lt;code&gt;multiCostRegular&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;FiniteAutomaton&lt;/code&gt; embeds an &lt;code&gt;Automaton&lt;/code&gt; object provided by the &lt;code&gt;dk.brics.automaton&lt;/code&gt; library.
Such an automaton accepts fixed-size words made of multiple &lt;code&gt;char&lt;/code&gt;, but the regular constraints rely on &lt;code&gt;IntVar&lt;/code&gt;,
so a mapping between &lt;code&gt;char&lt;/code&gt; (needed by the underlying library) and &lt;code&gt;int&lt;/code&gt; (declared in &lt;code&gt;IntVar&lt;/code&gt;) has been made.
The mapping enables declaring regular expressions where a symbol is not only a digit between 0 and 9 but any &lt;strong&gt;positive&lt;/strong&gt; number.
Then to distinct, in the word 101, the symbols 0, 1, 10 and 101, two additional &lt;code&gt;char&lt;/code&gt; are allowed in a regexp: &amp;lt; and &amp;gt; which delimits numbers.&lt;/p&gt;
&lt;p&gt;In summary, a valid regexp for the automaton-based constraints is a combination of &lt;strong&gt;digits&lt;/strong&gt; and Java Regexp special characters.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CostAutomaton&lt;/code&gt; is an extension of &lt;code&gt;FiniteAutomaton&lt;/code&gt; where costs can be declared for each transition.&lt;/p&gt;
&lt;h3 id=&#34;designing-your-own-constraint&#34;&gt;Designing your own constraint&lt;/h3&gt;
&lt;p&gt;You can create your own constraint by creating a generic &lt;code&gt;Constraint&lt;/code&gt; object with the appropriate propagators:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Constraint c = new Constraint(&amp;quot;MyConstraint&amp;quot;, new MyPropagator(vars));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The only tricky part lies in the propagator implementation.
Your propagator must extend the &lt;code&gt;Propagator&lt;/code&gt; class but not all methods have to be overwritted.
We will see two ways to implement a propagator ensuring that &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;basic-propagator&#34;&gt;Basic propagator&lt;/h4&gt;
&lt;p&gt;You must at least call the super constructor to specifies the scope (set of variables) of the propagator.
Then you must implement the two following methods:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void propagate(int evtmask)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method applies the global filtering algorithm of the propagator, that is, from &lt;em&gt;scratch&lt;/em&gt;.
It is called once during initial propagation (to propagate initial domains) and then during the solving process if
the propagator is not incremental. It is the most important method of the propagator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;isEntailed()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method checks the current state of the propagator. It is used for constraint reification.
It checks whether the propagator will be always satisfied (&lt;code&gt;ESat.TRUE&lt;/code&gt;), never satisfied (&lt;code&gt;ESat.FALSE&lt;/code&gt;)
or undefined (&lt;code&gt;ESat.UNDEFINED&lt;/code&gt;) according to the current state of its domain variables. For instance,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A \neq B$ will always be satisfied when $A={0,1,2}$ and $B={4,5}$.&lt;/li&gt;
&lt;li&gt;$A = B$ will never be satisfied when $A={0,1,2}$ and $B={4,5}$.&lt;/li&gt;
&lt;li&gt;The entailment of $A \neq B$ cannot be defined when $A={0,1,2}$ and $B={1,2,3}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ESat isEntailed()&lt;/code&gt; implementation may be approximate
but should at least cover the case where all variables are instantiated, in order to check solutions.&lt;/p&gt;
&lt;p&gt;Here is an example of how to implement a propagator for &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Propagator to apply X &amp;gt;= Y
public class MySimplePropagator extends Propagator&amp;lt;IntVar&amp;gt; {

    IntVar x, y;

    public MySimplePropagator(IntVar x, IntVar y) {
        super(new IntVar[]{x,y});
        this.x = x;
        this.y = y;
    }

    @Override
    public void propagate(int evtmask) throws ContradictionException {
        x.updateLowerBound(y.getLB(), this);
        y.updateUpperBound(x.getUB(), this);
    }

    @Override
    public ESat isEntailed() {
        if (x.getUB() &amp;lt; y.getLB())
            return ESat.FALSE;
        else if (x.getLB() &amp;gt;= y.getUB())
            return ESat.TRUE;
        else
            return ESat.UNDEFINED;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;elaborated-propagator&#34;&gt;Elaborated propagator&lt;/h4&gt;
&lt;p&gt;The super constructor &lt;code&gt;super(Variable[], PropagatorPriority, boolean);&lt;/code&gt; brings more information.
&lt;code&gt;PropagatorPriority&lt;/code&gt; enables to optimize the propagation engine (low arity for fast propagators is better).
The boolean argument allows to specifies the propagator is incremental.
When set to &lt;code&gt;true&lt;/code&gt;, the method &lt;code&gt;propagate(int varIdx, int mask)&lt;/code&gt; must be implemented.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Note that if many variables are modified between two calls, a non-incremental filtering may be faster (and simpler).&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;propagate(int varIdx, int mask)&lt;/code&gt; defines the incremental filtering.
It is called for every variable &lt;code&gt;vars[varIdx]&lt;/code&gt; whose domain has changed since the last call.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;getPropagationConditions(int vIdx)&lt;/code&gt; enables not to react on every kind of domain modification.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;setPassive()&lt;/code&gt; enables to desactivate the propagator when it is entailed, to save time.
The propagator is automatically reactivated upon backtrack.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;why(...)&lt;/code&gt; explains the filtering, to allow learning.&lt;/p&gt;
&lt;p&gt;Here is an example of how to implement a propagator for &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Propagator to apply X &amp;gt;= Y
public final class MyIncrementalPropagator extends Propagator&amp;lt;IntVar&amp;gt; {

    IntVar x, y;

    public MyIncrementalPropagator(IntVar x, IntVar y) {
        super(new IntVar[]{x,y}, PropagatorPriority.BINARY, true);
        this.x = x;
        this.y = y;
    }

    @Override
    public int getPropagationConditions(int vIdx) {
        if (vIdx == 0) {
            // awakes if x gets instantiated or if its upper bound decreases
            return IntEventType.combine(IntEventType.INSTANTIATE, IntEventType.DECUPP);
        } else {
            // awakes if y gets instantiated or if its lower bound increases
            return IntEventType.combine(IntEventType.INSTANTIATE, IntEventType.INCLOW);
        }
    }

    @Override
    public void propagate(int evtmask) throws ContradictionException {
        x.updateLowerBound(y.getLB(), this);
        y.updateUpperBound(x.getUB(), this);
        if (x.getLB() &amp;gt;= y.getUB()) {
            this.setPassive();
        }
    }

    @Override
    public void propagate(int varIdx, int mask) throws ContradictionException {
        if (varIdx == 0) {
            y.updateUpperBound(x.getUB(), this);
        } else {
            x.updateLowerBound(y.getLB(), this);
        }
        if (x.getLB() &amp;gt;= y.getUB()) {
            this.setPassive();
        }
    }

    @Override
    public ESat isEntailed() {
        if (x.getUB() &amp;lt; y.getLB())
            return ESat.FALSE;
        else if (x.getLB() &amp;gt;= y.getUB())
            return ESat.TRUE;
        else
            return ESat.UNDEFINED;
    }

    @Override
    public boolean why(RuleStore ruleStore, IntVar var, IEventType evt, int value) {
        boolean newrules = ruleStore.addPropagatorActivationRule(this);
        if (var.equals(x)) {
            newrules |=ruleStore.addLowerBoundRule(y);
        } else if (var.equals(y)) {
            newrules |=ruleStore.addUpperBoundRule(x);
        } else {
            newrules |=super.why(ruleStore, var, evt, value);
        }
        return newrules;
    }

    @Override
    public String toString() {
        return &amp;quot;prop(&amp;quot; + vars[0].getName() + &amp;quot;.GEQ.&amp;quot; + vars[1].getName() + &amp;quot;)&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;idempotency&#34;&gt;Idempotency&lt;/h3&gt;
&lt;p&gt;We distinguish two kinds of propagators:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Necessary&lt;/em&gt; propagators, which ensure constraints to be satisfied.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Redundant&lt;/em&gt; (or &lt;em&gt;Implied&lt;/em&gt;) propagators that come in addition to some necessary propagators in order to get a stronger filtering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some propagators cannot be idempotent (Lagrangian relaxation, use of randomness, etc.).
For some others, forcing idempotency may be very time consuming.
A redundant propagator does not have to be idempotent but &lt;strong&gt;a necessary propagator should be idempotent&lt;/strong&gt;  .&lt;/p&gt;
&lt;p&gt;Trying to make a propagator idempotent directly may not be straightforward.
We provide three implementation possibilities.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;decomposed&lt;/em&gt;  (recommended) option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Split the original propagator into (partial) propagators so that the fix point is performed through the propagation engine.
For instance, a channeling propagator $A \Leftrightarrow B$ can be decomposed into two propagators $A \Rightarrow B$ and $B \Rightarrow A$.
The propagators can (but do not have to) react on fine events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;lazy&lt;/em&gt; option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Simply post the propagator twice.
Thus, the fix point is performed through the propagation engine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;coarse&lt;/em&gt; option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the propagator will perform its fix point by itself.
The propagator does not react to fine events.
The coarse filtering algorithm should be surrounded like this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;// In the case of ``SetVar``, replace ``getDomSize()`` by ``getEnvSize()-getKerSize()``.
long size;
do{
  size = 0;
  for(IntVar v:vars){
    size+=v.getDomSize();
  }
  // really update domain variables here
  for(IntVar v:vars){
    size-=v.getDomSize();
  }
}while(size&amp;gt;0);
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Domain variable modifier returns a boolean valued to &lt;code&gt;true&lt;/code&gt; if the domain variable has been modified.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: </title>
      <link>/docs/solving/to-remove/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/solving/to-remove/</guid>
      <description>
        
        
        &lt;h1 id=&#34;solving&#34;&gt;Solving&lt;/h1&gt;
&lt;h2 id=&#34;core-solving-methods&#34;&gt;Core solving methods&lt;/h2&gt;
&lt;h3 id=&#34;solution-computation&#34;&gt;Solution computation&lt;/h3&gt;
&lt;h4 id=&#34;finding-one-solution&#34;&gt;Finding one solution&lt;/h4&gt;
&lt;p&gt;A call to &lt;code&gt;solver.solve()&lt;/code&gt; launches a resolution which stops on the first solution found, if any:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(solver.solve()){
    // do something, e.g. print out variable values
}else if(solver.hasReachedLimit()){
    System.out.println(&amp;quot;The solver could not find a solution
                        nor prove that none exists in the given limits&amp;quot;);
}else {
    System.out.println(&amp;quot;The solver has proved the problem has no solution&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If &lt;code&gt;solver.solve()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then a solution has been found and each variable is instantiated to a value.
Otherwise, two cases must be considered:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A limit has been declared and reached (&lt;code&gt;solver.hasReachedLimit()&lt;/code&gt; returns true).
There may be a solution, but the solver has not been able to find it in the given limit
or there is no solution but the solver has not been able to prove it (i.e., to close to search tree) in the given limit.
The resolution process stops in no particular place in the search tree.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No limit has been declared or reached: The problem has no solution and the solver has proved it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;enumerating-all-solutions&#34;&gt;Enumerating all solutions&lt;/h4&gt;
&lt;p&gt;You can enumerate all solutions of a problem with a simple while loop as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while(solver.solve()){
    // do something, e.g. print out variable values
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After the enumeration, the solver closes the search tree and variables are no longer instantiated to a value.&lt;/p&gt;
&lt;h3 id=&#34;optimization&#34;&gt;Optimization&lt;/h3&gt;
&lt;p&gt;In Constraint-Programming, optimization is done by computing improving solutions, until reaching an optimum.
Therefore, it can be seen as solving multiple times the model while adding constraints on the fly to prevent the solver from computing dominated solutions.&lt;/p&gt;
&lt;h4 id=&#34;mono-objective-optimization&#34;&gt;Mono-objective optimization&lt;/h4&gt;
&lt;p&gt;The optimization process is the following: anytime a solution is found, the value of the objective variable is stored and a &lt;em&gt;cut&lt;/em&gt; is posted.
The cut is an additional constraint which states that the next solution must be (strictly) better than the current one.
To solve an optimization problem, you must specify which variable to optimize and in which direction:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// to maximize X
model.setObjective(Model.MAXIMIZE, X);
// or model.setObjective(Model.MINIMIZE, X); to minimize X
while(solver.solve()){
    // an improving solution has been found
}
// the last solution found was optimal (if search completed)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can use custom cuts by overriding the default cut behavior.
The &lt;em&gt;cut computer&lt;/em&gt; function defines how the cut should bound the objective variable.
The input &lt;em&gt;number&lt;/em&gt; is the best solution value found so far, the output &lt;em&gt;number&lt;/em&gt; define the new bound.
When maximizing (resp. minimizing) a problem, the cut limits the lower bound (resp. upper bound) of the objective variable.
For instance, one may want to indicate that the value of the objective variable is the next solution should be
greater than or equal to the best value + 10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ObjectiveManager&amp;lt;IntVar, Integer&amp;gt; oman = solver.getObjectiveManager();
oman.setCutComputer(n -&amp;gt; n - 10);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;multi-objective-optimization&#34;&gt;Multi-objective optimization&lt;/h4&gt;
&lt;p&gt;If you have multiple objective to optimize, you have several options. First, you may aggregate them in a function so that you end up with only one objective variable. Second, you can solve the problem multiple times, each one optimizing one variable and possibly fixing some bounds on the other. Third, you can enumerate solutions (without defining any objective) and add constraints on the fly to prevent search from finding dominated solutions. This is done by the ParetoOptimizer object which does the following:
Anytime a solution is found, a constraint is posted which states that at least one of the objective variables must be strictly better:
Such as $(X_0 &amp;lt; b_0 \lor X_1 &amp;lt; b_1 \lor \ldots \lor X_n &amp;lt; b_n)$ where $X_i$ is the ith objective variable and $b_i$ its value.&lt;/p&gt;
&lt;p&gt;Here is a simple example on how to use the ParetoOptimizer to optimize two variables (a and b):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// simple model
Model model = new Model();
IntVar a = model.intVar(&amp;quot;a&amp;quot;, 0, 2, false);
IntVar b = model.intVar(&amp;quot;b&amp;quot;, 0, 2, false);
IntVar c = model.intVar(&amp;quot;c&amp;quot;, 0, 2, false);
model.arithm(a, &amp;quot;+&amp;quot;, b, &amp;quot;=&amp;quot;, c).post();

// create an object that will store the best solutions and remove dominated ones
ParetoOptimizer po = new ParetoOptimizer(Model.MAXIMIZE,new IntVar[]{a,b});
Solver solver = model.getSolver();
solver.plugMonitor(po);

// optimization
while(solver.solve());

// retrieve the pareto front
List&amp;lt;Solution&amp;gt; paretoFront = po.getParetoFront();
System.out.println(&amp;quot;The pareto front has &amp;quot;+paretoFront.size()+&amp;quot; solutions : &amp;quot;);
for(Solution s:paretoFront){
        System.out.println(&amp;quot;a = &amp;quot;+s.getIntVal(a)+&amp;quot; and b = &amp;quot;+s.getIntVal(b));
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: All objectives must be optimized on the same direction (either minimization or maximization).&lt;/p&gt;
&lt;h3 id=&#34;constraint-propagation&#34;&gt;Constraint propagation&lt;/h3&gt;
&lt;p&gt;One may want to propagate all constraints without search for a solution.
This can be achieved by calling &lt;code&gt;solver.propagate()&lt;/code&gt;.
This method runs, in turn, the domain reduction algorithms of the constraints until it reaches a fix point.
It may throw a &lt;code&gt;ContradictionException&lt;/code&gt; if a contradiction occurs.
In that case, the propagation engine must be flushed calling &lt;code&gt;solver.getEngine().flush()&lt;/code&gt;
to ensure there is no pending events.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: If there are still pending events in the propagation engine, the propagation may results in unexpected results.&lt;/p&gt;
&lt;h3 id=&#34;accessing-variable-values&#34;&gt;Accessing variable values&lt;/h3&gt;
&lt;p&gt;The value of a variable can be accessed directly through the &lt;code&gt;getValue()&lt;/code&gt; method only once the variable is instantiated, i.e. the value has been computed
(call &lt;code&gt;isInstantiated()&lt;/code&gt; to check it). Otherwise, the lower bound is returned (and an exception is thrown if &lt;code&gt;-ea&lt;/code&gt; is on).&lt;/p&gt;
&lt;p&gt;For instance, the following code may throw an exception because the solution has not been computed yet:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int v = variable.getValue();
solver.solve();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The following code may throw an exception in case no solution could be found (unsat problem or time limit reached):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.solve();
int v = variable.getValue();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The correct approach is the following :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(solver.solve()){
    int v = variable.getValue();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In optimization, you can print every solution as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while(solver.solve()){
    System.out.println(variable.getValue());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The last print correspond to the best solution found.&lt;/p&gt;
&lt;p&gt;However, the following code does &lt;em&gt;NOT&lt;/em&gt; display the best solution found:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while(solver.solve()){
    System.out.println(variable.getValue());
}
System.out.println(&amp;quot;best solution found: &amp;quot;+variable.getValue());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Because it is outside the while loop, this code is reached once the search tree has been closed.
It does not correspond to a solution state and therefore variable is no longer instantiated at this stage.
To use solutions afterward, you need to record them using &lt;code&gt;Solution&lt;/code&gt; objects.&lt;/p&gt;
&lt;h3 id=&#34;recording-solutions&#34;&gt;Recording solutions&lt;/h3&gt;
&lt;p&gt;A solution can be stored through a &lt;code&gt;Solution&lt;/code&gt; object which maps every variable with its current value.
It can be created as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solution solution = new Solution(model);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By default, a solution records the value of every variable, but you can specify a smaller scope in the &lt;code&gt;Solution&lt;/code&gt; constructor.&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;X&lt;/code&gt; be the set of decision variables and &lt;code&gt;Y&lt;/code&gt; another variable set that you need to store.
To record other variables (e.g. an objective variables) you have two options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Declare them in the search strategy using a complementary strategy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;solver.set(strategy(X),strategy(Y)).
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Specify which variables to store in the solution constructor&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Solution solution = new Solution(model(), ArrayUtils.append(X,Y));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can record the last solution found as follows :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solution solution = new Solution(model);
while (solver.solve()) {
    solution.record();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can also use a monitor as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solution solution = new Solution(model);
solver.plugMonitor(new IMonitorSolution() {
      @Override
      public void onSolution() {
          s.record();
      }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or with lambdas:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solution solution = new Solution(model);
solver.plugMonitor((IMonitorSolution) () -&amp;gt; s.record());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the solution is erased on each new recording.
To store all solutions, you need to create one new solution object for each solution.&lt;/p&gt;
&lt;p&gt;You can then access the value of a variable in a solution as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int val = s.getIntVal(Y[0])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The solution object can be used to store all variables in Choco Solver (binaries, integers, sets and reals)&lt;/p&gt;
&lt;h3 id=&#34;search-monitors&#34;&gt;Search monitors&lt;/h3&gt;
&lt;h4 id=&#34;principle&#34;&gt;Principle&lt;/h4&gt;
&lt;p&gt;A search monitor is an observer of the resolver.
It gives user access before and after executing each main step of the solving process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;initialize: when the solving process starts and the initial propagation is run,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;open node: when a decision is computed,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;down branch: on going down in the tree search applying or refuting a decision,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;up branch: on going up in the tree search to reconsider a decision,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;solution: when a solution is got,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;restart search: when the search is restarted to a previous node, commonly the root node,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;close: when the solving process ends,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;contradiction: on a failure,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the accurate search monitor, one can easily observe with the resolver, from pretty printing of a solution to learning nogoods from restart, or many other actions.&lt;/p&gt;
&lt;p&gt;The interfaces to implement are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorInitialize&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorOpenNode&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorDownBranch&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorUpBranch&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorSolution&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorRestart&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorContradiction&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorClose&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of them gives the opportunity to do something before and after a step. The other ones are called after a step.&lt;/p&gt;
&lt;p&gt;Simple example to print every solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.plugMonitor(new IMonitorSolution() {
    @Override
    public void onSolution() {
        System.out.println(&amp;quot;x = &amp;quot;+x.getValue());
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Java 8 style:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.plugMonitor((IMonitorSolution) () -&amp;gt; {System.out.println(&amp;quot;x = &amp;quot;+x.getValue());});
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;search-limits&#34;&gt;Search limits&lt;/h3&gt;
&lt;h4 id=&#34;built-in-search-limits&#34;&gt;Built-in search limits&lt;/h4&gt;
&lt;p&gt;Search can be limited in various ways using the &lt;code&gt;Solver&lt;/code&gt; (from &lt;code&gt;model.getSolver()&lt;/code&gt;).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;limitTime&lt;/code&gt; stops the search when the given time limit has been reached. This is the most common limit, as many applications have a limited available runtime.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The potential search interruption occurs at the end of a propagation, i.e. it will not interrupt a propagation algorithm, so the overall runtime of the solver might exceed the time limit.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitSolution&lt;/code&gt; stops the search when the given solution limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitNode&lt;/code&gt; stops the search when the given search node limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitFail&lt;/code&gt; stops the search when the given fail limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitBacktrack&lt;/code&gt; stops the search when the given backtrack limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For instance, to interrupt search after 10 seconds:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.limitTime(&amp;quot;10s&amp;quot;);
model.getSolver().solve();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;custom-search-limits&#34;&gt;Custom search limits&lt;/h4&gt;
&lt;p&gt;You can design you own search limit by implementing a &lt;code&gt;Criterion&lt;/code&gt; and using &lt;code&gt;resolver.limitSearch(Criterion c)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.limitSearch(new Criterion() {
    @Override
    public boolean isMet() {
        // todo return true if you want to stop search
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In Java 8, this can be shortened using lambda expressions:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.limitSearch(() -&amp;gt; { /*todo return true if you want to stop search*/ });
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;using-resolution-statistics&#34;&gt;Using resolution statistics&lt;/h3&gt;
&lt;p&gt;Resolution data are available in the &lt;code&gt;Solver&lt;/code&gt; object, whose default output is &lt;code&gt;System.out&lt;/code&gt;.
It centralises widely used methods to have comprehensive feedback about the resolution process.
There are two types of methods: those who need to be called &lt;strong&gt;before&lt;/strong&gt; the resolution, with a prefix show, and those who need to called &lt;strong&gt;after&lt;/strong&gt; the resolution, with a prefix print.&lt;/p&gt;
&lt;p&gt;For instance, one can indicate to print the solutions all resolution long:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.showSolutions();
solver.findAllSolutions();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or to print the search statistics once the search ends:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.solve();
solver.printStatistics();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On a call to &lt;code&gt;solver.printVersion()&lt;/code&gt;, the following message will be printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;** Choco 4.10.2 (2019-10) : Constraint Programming Solver, Copyright (c) 2010-2019
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On a call to &lt;code&gt;solver.printStatistics()&lt;/code&gt;, the following message will be printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;- [ Search complete - [ No solution | {0} solution(s) found ]
  | Incomplete search - [ Limit reached | Unexpected interruption ] ].
   Solutions: {0}
[  Maximize = {1}  ]
[  Minimize = {2}  ]
   Building time : {3}s
   Resolution : {6}s
   Nodes: {7} ({7}/{6} n/s)
   Backtracks: {8}
   Fails: {9}
   Restarts: {10}
   Max depth: {11}
   Variables: {12}
   Constraints: {13}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Curly brackets &lt;em&gt;{instruction | }&lt;/em&gt; indicate alternative instructions&lt;/p&gt;
&lt;p&gt;Brackets &lt;em&gt;[instruction]&lt;/em&gt; indicate an optional instruction.&lt;/p&gt;
&lt;p&gt;If the search terminates, the message “Search complete” appears on the first line, followed with either the number of solutions found or the message “No solution”.
&lt;code&gt;Maximize&lt;/code&gt; –resp. &lt;code&gt;Minimize&lt;/code&gt;– indicates the best known value for the objective variable before exiting when an (single) objective has been defined.&lt;/p&gt;
&lt;p&gt;Curly braces &lt;em&gt;{value}&lt;/em&gt; indicate search statistics:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;number of solutions found&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;objective value in maximization&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;objective value in minimization&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;building time in second (from &lt;code&gt;new Model()&lt;/code&gt; to &lt;code&gt;solve()&lt;/code&gt; or equivalent)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;initialisation time in second (before initial propagation)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;initial propagation time in second&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resolution time in second (from &lt;code&gt;new Model()&lt;/code&gt; till now)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number of nodes in the binary tree search : one for the root node and between one and two for each decision (two when the decision has been refuted)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number of backtracks achieved&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number of failures that occurred (conflict number)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number of restarts operated&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;maximum depth reached in the binary tree search&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number of variables in the model&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number of constraints in the model&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If the resolution process reached a limit before ending &lt;em&gt;naturally&lt;/em&gt;, the title of the message is set to :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;- Incomplete search - Limit reached.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The body of the message remains the same. The message is formatted thanks to the &lt;code&gt;IMeasureRecorder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;On a call to &lt;code&gt;solver.showSolutions()&lt;/code&gt;, on each solution the following message will be printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;{0} Solutions, [Maximize = {1}][Minimize = {2}], Resolution {6}s, {7} Nodes, \\
                                    {8} Backtracks, {9} Fails, {10} Restarts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;followed by one line exposing the value of each decision variables (those involved in the search strategy).&lt;/p&gt;
&lt;p&gt;On a call to &lt;code&gt;solver.showDecisions()&lt;/code&gt;, on each node of the search tree a message will be printed indicating which decision is applied.
The message is prefixed by as many “.” as nodes in the current branch of the search tree.
A decision is prefixed with &lt;code&gt;[R]&lt;/code&gt; and a refutation is prefixed by &lt;code&gt;[L]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34; data-lang=&#34;none&#34;&gt;..[L]x  ==  1 (0) //X = [0,5] Y = [0,6] ...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: &lt;code&gt;solver.showDecisions()&lt;/code&gt; prints the tree search during the resolution.
Printing the decisions slows down the search process.&lt;/p&gt;
&lt;h2 id=&#34;search-strategies&#34;&gt;Search Strategies&lt;/h2&gt;
&lt;p&gt;The search space induced by variable domains is equal to  $S=|d_1|&lt;em&gt;|d_2|&lt;/em&gt;&amp;hellip;*|d_n|$ where $d_i$ is the domain of the $i^{th}$ variable.
Most of the time (not to say always), constraint propagation is not sufficient to build a solution, that is, to remove all values but one from variable domains.
Thus, the search space needs to be explored using one or more &lt;em&gt;search strategies&lt;/em&gt;.
A search strategy defines how to explore the search space by computing &lt;em&gt;decisions&lt;/em&gt;.
A decision involves a variables, a value and an operator, e.g. $x = 5$, and triggers new constraint propagation.
Decisions are computed and applied until all the variables are instantiated, that is, a solution has been found, or a failure has been detected (backtrack occurs).
Choco 4.10.2 builds a binary search tree: each decision can be refuted (if $x = 5$ leads to no solution, then $x != 5$ is applied).
The classical search is based on &lt;a href=&#34;http://en.wikipedia.org/wiki/Depth-first_search&#34;&gt;Depth First Search&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: There are many ways to explore the search space and this steps should not be overlooked.
Search strategies or heuristics have a strong impact on resolution performances.
Thus, it is strongly recommended to adapt the search space exploration to the problem treated.&lt;/p&gt;
&lt;h3 id=&#34;default-search-strategy&#34;&gt;Default search strategy&lt;/h3&gt;
&lt;p&gt;If no search strategy is specified to the resolver, Choco 4 will rely on the default one (defined by a &lt;code&gt;defaultSearch&lt;/code&gt; in &lt;code&gt;Search&lt;/code&gt;).
In many cases, this strategy will not be sufficient to produce satisfying performances and it will be necessary to specify a dedicated strategy, using &lt;code&gt;solver.setSearch(...)&lt;/code&gt;.
The default search strategy splits variables according to their type and defines specific search strategies for each type that are sequentially applied:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;integer variables and boolean variables : &lt;code&gt;intVarSearch(ivars)&lt;/code&gt; (calls &lt;code&gt;domOverWDegSearch&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set variables: &lt;code&gt;setVarSearch(svars)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;real variables &lt;code&gt;realVarSearch(rvars)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;objective variable, if any: lower bound or upper bound, depending on the optimization direction&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that lastConflict is also plugged-in.&lt;/p&gt;
&lt;h3 id=&#34;specifying-a-search-strategy&#34;&gt;Specifying a search strategy&lt;/h3&gt;
&lt;p&gt;You may specify a search strategy to the resolver by using &lt;code&gt;solver.setSearch(...)&lt;/code&gt; method as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import static org.chocosolver.solver.search.strategy.Search.*;

// to use the default SetVar search on mySetVars
Solver s = model.getSolver();
s.setSearch(setVarSearch(mySetVars));

// to use activity based search on myIntVars
Solver s = model.getSolver();
s.setSearch(activityBasedSearch(myIntVars));

// to use activity based search on myIntVars
// then the default SetValSelectorFactoryVar search on mySetVars
Solver s = model.getSolver();
s.setSearch(activityBasedSearch(myIntVars), setVarSearch(mySetVars));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Search strategies generally hold on some particular variable kinds only (e.g. integers, sets, etc.).&lt;/p&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;p&gt;Let us consider we have two integer variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and we want our strategy to select
the variable of smallest domain and assign it to its lower bound.
There are several ways to achieve this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 1) verbose approach using usual imports

import org.chocosolver.solver.search.strategy.Search;
import org.chocosolver.solver.search.strategy.assignments.DecisionOperator;
import org.chocosolver.solver.search.strategy.selectors.values.*;
import org.chocosolver.solver.search.strategy.selectors.variables.*;


    Solver s = model.getSolver();
    s.setSearch(Search.intVarSearch(
                    // selects the variable of smallest domain size
                    new FirstFail(model),
                    // selects the smallest domain value (lower bound)
                    new IntDomainMin(),
                    // apply equality (var = val)
                    DecisionOperator.int_eq,
                    // variables to branch on
                    x, y
    ));

// 2) Shorter approach : Use a static import for Search
// and do not specify the operator (equality by default)

import static org.chocosolver.solver.search.strategy.Search.*;

import org.chocosolver.solver.search.strategy.assignments.DecisionOperator;
import org.chocosolver.solver.search.strategy.selectors.values.*;
import org.chocosolver.solver.search.strategy.selectors.variables.*;


    Solver s = model.getSolver();
    s.setSearch(intVarSearch(
                    // selects the variable of smallest domain size
                    new FirstFail(model),
                    // selects the smallest domain value (lower bound)
                    new IntDomainMin(),
                    // variables to branch on
                    x, y
    ));


// 3) Shortest approach using built-in strategies imports

import static org.chocosolver.solver.search.strategy.Search.*;

    Solver s = model.getSolver();
    s.setSearch(minDomLBSearch(x, y));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;list-of-available-search-strategy&#34;&gt;List of available search strategy&lt;/h3&gt;
&lt;p&gt;Most available search strategies are listed in &lt;code&gt;Search&lt;/code&gt;.
This factory enables you to create search strategies using static methods.
Most search strategies rely on :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;variable selectors (see package &lt;code&gt;org.chocosolver.solver.search.strategy.selectors.values&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;value selectors (see package &lt;code&gt;org.chocosolver.solver.search.strategy.selectors.variables&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;operators (see &lt;code&gt;DecisionOperator&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Search&lt;/code&gt; is not exhaustive, look at the selectors package to see learn more search possibilities.&lt;/p&gt;
&lt;h3 id=&#34;designing-your-own-search-strategy&#34;&gt;Designing your own search strategy&lt;/h3&gt;
&lt;h4 id=&#34;using-selectors&#34;&gt;Using selectors&lt;/h4&gt;
&lt;p&gt;To design your own strategy using Search.intVarSearch, you simply have to implement
your own variable and value selectors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static IntStrategy intVarSearch(VariableSelector&amp;lt;IntVar&amp;gt; varSelector,
                                    IntValueSelector valSelector,
                                    IntVar... vars)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For instance, to select the first non instantiated variable and assign it to its lower bound:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.setSearch(intVarSearch(
        // variable selector
        (VariableSelector&amp;lt;IntVar&amp;gt;) variables -&amp;gt; {
            for(IntVar v:variables){
                if(!v.isInstantiated()){
                    return v;
                }
            }
            return null;
        },
        // value selector
        (IntValueSelector) var -&amp;gt; var.getLB(),
        // variables to branch on
        x, y
));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: When all variables are instantiated, a &lt;code&gt;VariableSelector&lt;/code&gt; must return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;from-scratch&#34;&gt;From scratch&lt;/h4&gt;
&lt;p&gt;You can design your own strategy by creating &lt;code&gt;Decision&lt;/code&gt; objects directly as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s.setSearch(new AbstractStrategy&amp;lt;IntVar&amp;gt;(x,y) {
    // enables to recycle decision objects (good practice)
    PoolManager&amp;lt;IntDecision&amp;gt; pool = new PoolManager();
    @Override
    public Decision getDecision() {
        IntDecision d = pool.getE();
        if(d==null) d = new IntDecision(pool);
        IntVar next = null;
        for(IntVar v:vars){
            if(!v.isInstantiated()){
                next = v; break;
            }
        }
        if(next == null){
            return null;
        }else {
            // next decision is assigning nextVar to its lower bound
            d.set(next,next.getLB(), DecisionOperator.int_eq);
            return d;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;making-a-decision-greedy&#34;&gt;Making a decision greedy&lt;/h3&gt;
&lt;p&gt;You can make a decision non-refutable by using &lt;code&gt;decision.setRefutable(false)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;To make an entire search strategy greedy, use:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.setSearch(greedySearch(inputOrderLBSearch(x,y,z)));
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;restarts&#34;&gt;Restarts&lt;/h3&gt;
&lt;p&gt;Restart means stopping the current tree search, then starting a new tree search from the root node.
Restarting makes sense only when coupled with randomized dynamic branching strategies ensuring that the same enumeration tree is not constructed twice.
The branching strategies based on the past experience of the search, such as adaptive search strategies, are more accurate in combination with a restart approach.&lt;/p&gt;
&lt;p&gt;Unless the number of allowed restarts is limited, a tree search with restarts is not complete anymore. It is a good strategy, though, when optimizing an NP-hard problem in a limited time.&lt;/p&gt;
&lt;p&gt;Some adaptive search strategies resolutions are improved by sometimes restarting the search exploration from the root node.
Thus, the statistics computed on the bottom of the tree search can be applied on the top of it.&lt;/p&gt;
&lt;p&gt;Several restart strategies are available in &lt;code&gt;Solver&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Restarts after after each new solution.
solver.setRestartOnSolutions()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Geometrical restarts perform a search with restarts controlled by the resolution event  &lt;code&gt;counter&lt;/code&gt; which counts events occurring during the search.
Parameter &lt;code&gt;base&lt;/code&gt; indicates the maximal number of events allowed in the first search tree.
Once this limit is reached, a restart occurs and the search continues until &lt;code&gt;base\&lt;/code&gt;`*``grow&lt;code&gt;events are done, and so on. After each restart, the limit number of events is increased by the geometric factor&lt;/code&gt;grow&lt;code&gt;.&lt;/code&gt;limit` states the maximum number of restarts.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.setGeometricalRestart(int base, double grow, ICounter counter, int limit)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Some counters may required an argument on constructor that defines the limit to not overpass.
Such an argument is ignored by a restart strategy which overrides that value with its own computed one.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.5558&#34;&gt;Luby&lt;/a&gt; ’s restart policy is an alternative to the geometric restart policy.
It performs a search with restarts controlled by the number of resolution events  counted by &lt;code&gt;counter&lt;/code&gt;.
The maximum number of events allowed at a given restart iteration is given by base multiplied by the Las Vegas coefficient at this iteration.
The sequence of these coefficients is defined recursively on its prefix subsequences:
starting from the first prefix $1$, the $(k+1)^th$ prefix is the $k^th$ prefix repeated &lt;code&gt;grow&lt;/code&gt; times and
immediately followed by coefficient &lt;code&gt;grow&lt;/code&gt;$^k$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the first coefficients for &lt;code&gt;grow&lt;/code&gt; =2: [1,1,2,1,1,2,4,1,1,2,1,1,2,4,8,1,…]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the first coefficients for &lt;code&gt;grow&lt;/code&gt; =3 : [1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 3, 9,…]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;solver.setLubyRestart(int base, int grow, ICounter counter, int limit)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can design your own restart strategies using:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.setRestarts( LongCriterion restartCriterion,
                    IRestartStrategy restartStrategy,
                    int restartsLimit);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;moves&#34;&gt;Moves&lt;/h2&gt;
&lt;h3 id=&#34;large-neighborhood-search-lns&#34;&gt;Large Neighborhood Search (LNS)&lt;/h3&gt;
&lt;p&gt;Local search techniques are very effective to solve hard optimization problems.
Most of them are, by nature, incomplete.
In the context of constraint programming (CP) for optimization problems, one of the most well-known and widely used local search techniques is the Large Neighborhood Search (LNS) algorithm .
The basic idea is to iteratively relax a part of the problem, then to use constraint programming to evaluate and bound the new solution.&lt;/p&gt;
&lt;h4 id=&#34;principle-1&#34;&gt;Principle&lt;/h4&gt;
&lt;p&gt;LNS is a two-phase algorithm which partially relaxes a given solution and repairs it.
Given a solution as input, the relaxation phase builds a partial solution (or neighborhood) by choosing a set of variables to reset to their initial domain;
The remaining ones are assigned to their value in the solution.
This phase is directly inspired from the classical Local Search techniques.
Even though there are various ways to repair the partial solution, we focus on the technique in which Constraint Programming is used to bound the objective variable and
to assign a value to variables not yet instantiated.
These two phases are repeated until the search stops (optimality proven or limit reached).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;INeighborFactory&lt;/code&gt; provides pre-defined configurations.
Here is the way to declare LNS to solve a problem:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.setLNS(INeighborFactory.random(ivars, new FailCounter(solver, 100));
solver.findOptimalSolution(Model.MINIMIZE, objective);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It declares a &lt;em&gt;random&lt;/em&gt; LNS which, on a solution, computes a partial solution based on &lt;code&gt;ivars&lt;/code&gt;.
If no solution are found within 100 fails (&lt;code&gt;FailCounter(solver, 100)&lt;/code&gt;), a restart is forced.&lt;/p&gt;
&lt;p&gt;The factory provides other built-in neighbors.&lt;/p&gt;
&lt;h4 id=&#34;neighbors&#34;&gt;Neighbors&lt;/h4&gt;
&lt;p&gt;While the implementation of LNS is straightforward, the main difficulty lies in the design of neighborhoods able to move the search further.
Indeed, the balance between diversification (i.e., evaluating unexplored sub-tree) and intensification (i.e., exploring them exhaustively) should be well-distributed.&lt;/p&gt;
&lt;h5 id=&#34;generic-neighbors&#34;&gt;Generic neighbors&lt;/h5&gt;
&lt;p&gt;One drawback of LNS is that the relaxation process is quite often problem dependent.
Some works have been dedicated to the selection of variables to relax through general concept not related to the class of the problem treated [5,24].
However, in conjunction with CP, only one generic approach, namely Propagation-Guided LNS [24], has been shown to be very competitive with dedicated ones on a variation of the Car Sequencing Problem.
Nevertheless, such generic approaches have been evaluated on a single class of problem and need to be thoroughly parametrized at the instance level, which may be a tedious task to do.
It must, in a way, automatically detect the problem structure in order to be efficient.&lt;/p&gt;
&lt;h5 id=&#34;combining-neighborhoods&#34;&gt;Combining neighborhoods&lt;/h5&gt;
&lt;p&gt;There are two ways to combine neighbors.&lt;/p&gt;
&lt;h6 id=&#34;sequential&#34;&gt;Sequential&lt;/h6&gt;
&lt;p&gt;Declare an instance of &lt;code&gt;SequenceNeighborhood(n1, n2, ..., nm)&lt;/code&gt;.
Each neighbor ni is applied in a sequence until one of them leads to a solution.
At step k, the $(k \mod m)^{th}$ neighbor is selected.
The sequence stops if at least one of the neighbor is complete.&lt;/p&gt;
&lt;h6 id=&#34;adaptive&#34;&gt;Adaptive&lt;/h6&gt;
&lt;p&gt;Declare an instance of &lt;code&gt;AdaptiveNeighborhood(1L, n1, n2, ..., nm)&lt;/code&gt;.
At the beginning a weight of 1 at assigned to each neighbor ni.
Then, if a neighbor leads to solution, its weight $w_i$ is increased by 1.
Any time a partial solution has to be computed, a value &lt;code&gt;W&lt;/code&gt; between 1 and $w_1+w_2+&amp;hellip;+w_n$ is randomly picked (&lt;code&gt;1L&lt;/code&gt; is the seed).
Then the weight of each neighbor is subtracted from &lt;code&gt;W&lt;/code&gt;, as soon as &lt;code&gt;W&lt;/code&gt;$\leq 0$, the corresponding neighbor is selected.
For instance, let’s consider three neighbors n1, n2 and n3, their respective weights w1=2, w2=4, w3=1.
&lt;code&gt;W&lt;/code&gt; = 3  is randomly picked between 1 and 7.
Then, the weight of n1 is subtracted, &lt;code&gt;W\&lt;/code&gt;`2-=1; the weight of n2 is subtracted, ``W&lt;code&gt;-4 = -3, &lt;/code&gt;W` is less than 0 and n2 is selected.&lt;/p&gt;
&lt;h5 id=&#34;defining-its-own-neighborhoods&#34;&gt;Defining its own neighborhoods&lt;/h5&gt;
&lt;p&gt;One can define its own neighbor by extending the abstract class &lt;code&gt;INeighbor&lt;/code&gt;.
It forces to implements the following methods:&lt;/p&gt;
&lt;p&gt;| &lt;strong&gt;Method&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;| &lt;strong&gt;Definition&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;|
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; |  |  |
|                                |                                                                                                                                                                                                 |
| &lt;code&gt;void recordSolution()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;      | Action to perform on a solution (typicallu, storing the current variables’ value).

                                                                                                          |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;|                                |                                                                                                                                                                                                 |
| &lt;code&gt;void fixSomeVariables()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    | Fix some variables to their value in the last solution.

                                                                                                                                     |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;|                                |                                                                                                                                                                                                 |
| &lt;code&gt;void restrictLess()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        | Relax the number of variables fixed. Called when no solution was found during a LNS run (trapped into a local optimum).

                                                                     |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;|                                |                                                                                                                                                                                                 |
| &lt;code&gt;boolean isSearchComplete()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; | Indicates whether the neighbor is complete, that is, can end.

                                                                                                                               |
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;restarts-1&#34;&gt;Restarts&lt;/h4&gt;
&lt;p&gt;A generic and common way to reinforce diversification of LNS is to introduce restart during the search process.
This technique has proven to be very flexible and to be easily integrated within standard backtracking procedures .&lt;/p&gt;
&lt;h4 id=&#34;walking&#34;&gt;Walking&lt;/h4&gt;
&lt;p&gt;A complementary technique that appear to be efficient in practice is named Walking and consists in accepting equivalent intermediate solutions in a search iteration instead of requiring a strictly better one.
This can be achieved by defining an &lt;code&gt;ObjectiveManager&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.setObjectiveManager(new ObjectiveManager(objective, ResolutionPolicy.MAXIMIZE, false));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where the last parameter, named &lt;code&gt;strict&lt;/code&gt; must be set to false to accept equivalent intermediate solutions.&lt;/p&gt;
&lt;p&gt;Other optimization policies may be encoded by using either search monitors or a custom &lt;code&gt;ObjectiveManager&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;learning&#34;&gt;Learning&lt;/h2&gt;
&lt;h3 id=&#34;explanations&#34;&gt;Explanations&lt;/h3&gt;
&lt;p&gt;Choco 4 natively support explanations . However, no explanation engine is plugged-in by default.&lt;/p&gt;
&lt;h4 id=&#34;principle-2&#34;&gt;Principle&lt;/h4&gt;
&lt;p&gt;Nogoods and explanations have long been used in various paradigms for improving search.
An explanation records some sufficient information to justify an inference made by the solver (domain reduction, contradiction, etc.).
It is made of a subset of the original propagators of the problem and a subset of decisions applied during search.
Explanations represent the logical chain of inferences made by the solver during propagation in an efficient and usable manner.
In a way, they provide some kind of a trace of the behavior of the solver as any operation needs to be explained.&lt;/p&gt;
&lt;p&gt;The implemented explanation framework is an adapation of the well-konw SAT &lt;a href=&#34;https://en.wikipedia.org/wiki/Conflict-driven_clause_learning&#34;&gt;CDCL algorithm&lt;/a&gt; to discrete constraint solver.
By exploiting the implication graph (that records events, i.e. variables’ modifications), this algorithm is able to derive a new constraint from the events that led to a contradiction.
Once added to the constraint network, this constraint makes possible to “backjump” (non-chronological backtrack) to the appropriate decision in the decision path.&lt;/p&gt;
&lt;p&gt;In CP, learned constraints are denoted “signed-clauses” which is a disjunction of signed-literals, i.e. membership unary constraints : $\bigvee_{i=0}^{n}X_i \in D_i$
where $X_i$ are variables and $D_i$ a set of values.
A signed-clause is satisfied when at least one signed-literal is satisfied.&lt;/p&gt;
&lt;p&gt;The current explanation engine is coded to be &lt;em&gt;Asynchronous, Reverse, Low-intrusive and Lazy&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;Asynchronous:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Explanations are not computed during the propagation.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reverse:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Explanations are computed in a bottom-up way, from the conflict to the first event generated, *keeping* only relevant events to compute the explanation of the conflict.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Low-intrusive:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Basically, propagators need to implement only one method to furnish a convenient explanation schema.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lazy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Explanations are computed on request.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do so, all events are stored during the descent to a conflict/solution, and are then evaluated and kept if relevant, to get the explanation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: In CP, CDCL algorithm requires that each constraint of a problem can be explained. Even though a default explanation function for any constraint, dedicated functions offers better performances.
In Choco 4 a few set of constraints is equipped with dedicated explanation function (unary constraints, binary and ternary, sum and scalar).&lt;/p&gt;
&lt;h5 id=&#34;computing-explanations&#34;&gt;Computing explanations&lt;/h5&gt;
&lt;p&gt;When a contradiction occurs during propagation, it can only be thrown by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a propagator which detects unsatisfiability, based on the current domain of its variables;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;or a variable whom domain became empty.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Consequently, in addition to causes, variables can also explain the current state of their domain.
Computing the explanation of a failure consists in going up in the stack of all events generated in the current branch of the search tree and filtering the one relative to the conflict.
The entry point is either the not satisfiable propagator or the empty variable.&lt;/p&gt;
&lt;p&gt;Each propagator embeds its own explanation algorithm which relies on the relation it defines over variables.&lt;/p&gt;
&lt;h4 id=&#34;explanations-for-the-system&#34;&gt;Explanations for the system&lt;/h4&gt;
&lt;p&gt;Explanations for the system, which try to reduce the search space, differ from the ones giving feedback to a user about the unsatisfiability of its model.
Both rely on the capacity of the explanation engine to motivate a failure, during the search form system explanations and once the search is complete for user ones.&lt;/p&gt;
&lt;h5 id=&#34;learning-signed-clauses&#34;&gt;Learning signed-clauses&lt;/h5&gt;
&lt;p&gt;When learning is plugged-in, the search is hacked in the following way.
On a failure, the implication graph is analyzed in order to build a signed-clause and to define the decision to jump back to it.
Decisions from the current one to the return decision (excluded) are erased.
Then, the signed-clause is added to the constraint network and automatically dominates decision refutation; then the search goes on.
If the explanation jumps back to the root node, the problem is proven to have no solution and search stops.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;solver.setLearningSignedClauses();
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;em&gt;solver&lt;/em&gt;: the solver to explain.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See Settings to configure learning algorithm.&lt;/p&gt;
&lt;h3 id=&#34;search-loop&#34;&gt;Search loop&lt;/h3&gt;
&lt;p&gt;The search loop whichs drives the search is a freely-adapted version PLM .
PLM stands for: Propagate, Learn and Move.
Indeed, the search loop is composed of three parts, each of them with a specific goal.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Propagate: it aims at propagating information throughout the constraint network when a decision is made,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Learn: it aims at ensuring that the search mechanism will avoid (as much as possible) to get back to states that have been explored and proved to be solution-less,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Move: it aims at, unlike the former ones, not pruning the search space but rather exploring it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Any component can be freely implemented and attached to the search loop in order to customize its behavior.
There exists some pre-defined Move and Learn implementations.
One can also define its own Move or Learn implementation.&lt;/p&gt;
&lt;h3 id=&#34;implementing-a-search-loop-component&#34;&gt;Implementing a search loop component&lt;/h3&gt;
&lt;p&gt;A search loop is made of three components, each of them dealing with a specific aspect of the search.
Even if many Move and Learn implementation are already provided, it may be relevant to define its own component.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: The Propagate component is less prone to be modified, it will not be described here.
However, its interface is minimalist and can be easily implemented.
A look to org.chocosolver.solver.search.loop.propagate.PropagateBasic.java is a good starting point.&lt;/p&gt;
&lt;p&gt;The two components can be easily set in the Solver search loop:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void setMove(Move m)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The current Move component is replaced by m.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Move getMove()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;The current Move component is returned.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;void setLearn(Learn l) and Learn getLearn() are also avaiable.&lt;/p&gt;
&lt;p&gt;Having access to the current Move (resp. Learn) component can be useful to combined it with another one.
For instance, the MoveLNS is activated on a solution and creates a partial solution.
It needs another Move to find the first solution and to complete the partial solution.&lt;/p&gt;
&lt;h4 id=&#34;move&#34;&gt;Move&lt;/h4&gt;
&lt;p&gt;Here is the API of Move:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;boolean extend(SearchLoop searchLoop)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Perform a move when the CSP associated to the current node of the search space is not proven to be not consistent.
It returns true if an extension can be done, false when no more extension is possible.
It has to maintain the correctness of the reversibility of the action by pushing a backup world when needed.
An extension is commonly based on a decision, which may be made on one or many variables.
If a decision is created (thanks to the search strategy), it has to be linked to the previous one.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;boolean repair(SearchLoop searchLoop)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Perform a move when the CSP associated to the current node of the search space is proven to be not consistent.
It returns true if a reparation can be done, false when no more reparation is possible.
It has to backtracking backup worlds when needed, and unlinked useless decisions.
The depth and number of backtracks have to be updated too, and “up branch” search monitors of the search loop have to called
(be careful, when many Move are combined).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Move getChildMove()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;It returns the child Move or null.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;void setChildMove(Move aMove)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;It defined the child Move and erases the previously defined one, if any.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;boolean init()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Called before the search starts, it should initialize the search strategy, if any, and its child Move.
It should return false if something goes wrong (the problem has trivially no solution), true otherwise.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AbstractStrategy&amp;lt;V&amp;gt; getStrategy()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;It returns the search strategy in use, which may be null if none has been defined.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;void setStrategy(AbstractStrategy&amp;lt;V&amp;gt; aStrategy)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;It defines a search strategy and erases the previously defined one, that is, a service which computes and returns decisions.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;org.chocosolver.solver.search.loop.move.MoveBinaryDFS.java&lt;/code&gt; is good starting point to see how a Move is implemented.
It defines a Depth-First Search with binary decisions.&lt;/p&gt;
&lt;h4 id=&#34;learn&#34;&gt;Learn&lt;/h4&gt;
&lt;p&gt;The aim of the component is to make sure that the search mechanism will avoid (as much as possible) to get back to states that have been explored and proved to be solution-less. Here is the API of Learn&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void record(SearchLoop searchLoop)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;It validates and records a new piece of knowledge, that is, the current position is a dead-end.
This is alwasy called *before* calling Move.repair(SearchLoop).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;void forget(SearchLoop searchLoop)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;It forgets some pieces of knowledge.
This is alwasy called *after* calling Move.repair(SearchLoop).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;org.chocosolver.solver.search.loop.learn.LearnCBJ&lt;/code&gt; is good, yet not trivial, example of Learn.&lt;/p&gt;
&lt;h2 id=&#34;multi-thread-resolution&#34;&gt;Multi-thread resolution&lt;/h2&gt;
&lt;p&gt;Choco 4 provides a simple way to use several threads to treat a problem. The main idea of that driver is to solve the &lt;em&gt;same&lt;/em&gt; model with different search strategies and to share few information to make these threads help each others.&lt;/p&gt;
&lt;p&gt;To use a portfolio of solvers in parallel, use &lt;code&gt;ParallelPortfolio&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ParallelPortfolio portfolio = new ParallelPortfolio();
int nbModels = 5;
for(int s=0;s&amp;lt;nbModels;s++){
    portfolio.addModel(makeModel());
}
portfolio.solve();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this example, &lt;code&gt;makeModel()&lt;/code&gt; is a method you have to implement to create a &lt;code&gt;Model&lt;/code&gt; of the problem.
Here all models are the same and the portfolio will change the search heuristics of all models but the first one.
This means that the first thread will run according to your settings whereas the others will have a different configuration.&lt;/p&gt;
&lt;p&gt;In order to specify yourself the configuration of each thread, you need to create the portfolio by setting the optional
boolean argument &lt;code&gt;searchAutoConf&lt;/code&gt; to false as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ParallelPortfolio portfolio = new ParallelPortfolio(false);
int nbModels = 5;
for(int s=0;s&amp;lt;nbModels;s++){
    portfolio.addModel(makeModel(s));
}
portfolio.solve();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In this second example, the parameter &lt;code&gt;s&lt;/code&gt; enables you to change the search strategy within the &lt;code&gt;makeModel&lt;/code&gt; method (e.g. using a &lt;code&gt;switch(s)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When dealing with multithreading resolution, very few data is shared between threads:
everytime a solution has been found its value is shared among solvers. Moreover,
when a solver ends, it communicates an interruption instruction to the others.
This enables to explore the search space in various way, using different model settings such as search strategies
(this should be done in the dedicated method which builds the model, though).&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
