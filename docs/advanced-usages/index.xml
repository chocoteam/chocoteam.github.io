<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Choco-solver – Advanced usages</title>
    <link>https://choco-solver.org/docs/advanced-usages/</link>
    <description>Recent content in Advanced usages on Choco-solver</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 07 Jan 2020 16:08:22 +0100</lastBuildDate>
    
	  <atom:link href="https://choco-solver.org/docs/advanced-usages/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Designing a propagator</title>
      <link>https://choco-solver.org/docs/advanced-usages/propagator/</link>
      <pubDate>Tue, 07 Jan 2020 16:07:15 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/propagator/</guid>
      <description>
        
        
        &lt;h3 id=&#34;designing-your-own-constraint&#34;&gt;Designing your own constraint&lt;/h3&gt;
&lt;p&gt;You can create your own constraint by creating a generic &lt;code&gt;Constraint&lt;/code&gt; object with the appropriate propagator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Constraint c = new Constraint(&amp;quot;MyConstraint&amp;quot;, new MyPropagator(vars));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only tricky part relies in the propagator implementation.
Your propagator must extend the &lt;code&gt;Propagator&lt;/code&gt; class but, at the begining, not all methods have to be overwritted.
We will see two ways to implement a propagator ensuring that &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A guided implementation of a scalar constraint is presented in the tutorial: &lt;a href=&#34;https://choco-solver.org/tutos/constraints/&#34;&gt;Designing a constraint&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;basic-propagator&#34;&gt;Basic propagator&lt;/h4&gt;
&lt;p&gt;You must at least call the super constructor to specifies the scope (set of variables) of the propagator.
Then you must implement the two following methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void propagate(int evtmask)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;This method applies the global filtering algorithm of the propagator, that is, from &lt;em&gt;scratch&lt;/em&gt;.
It is called once during initial propagation (to propagate initial domains) and then during the solving process if
the propagator is not incremental. It is the most important method of the propagator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ESat isEntailed()
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;This method checks the current state of the propagator. It is used for constraint reification.
It checks whether the propagator will be always satisfied (&lt;code&gt;ESat.TRUE&lt;/code&gt;), never satisfied (&lt;code&gt;ESat.FALSE&lt;/code&gt;)
or undefined (&lt;code&gt;ESat.UNDEFINED&lt;/code&gt;) according to the current state of its domain variables. For instance,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$A \neq B$ will always be satisfied when $A={0,1,2}$ and $B={4,5}$.&lt;/li&gt;
&lt;li&gt;$A = B$ will never be satisfied when $A={0,1,2}$ and $B={4,5}$.&lt;/li&gt;
&lt;li&gt;The entailment of $A \neq B$ cannot be defined when $A={0,1,2}$ and $B={1,2,3}$.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ESat isEntailed()&lt;/code&gt; implementation may be approximate
but should at least cover the case where all variables are instantiated, in order to check solutions.&lt;/p&gt;
&lt;p&gt;Here is an example of how to implement a propagator for &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Propagator to apply X &amp;gt;= Y
public class MySimplePropagator extends Propagator&amp;lt;IntVar&amp;gt; {

    IntVar x, y;

    public MySimplePropagator(IntVar x, IntVar y) {
        super(new IntVar[]{x,y});
        this.x = x;
        this.y = y;
    }

    @Override
    public void propagate(int evtmask) throws ContradictionException {
        x.updateLowerBound(y.getLB(), this);
        y.updateUpperBound(x.getUB(), this);
    }

    @Override
    public ESat isEntailed() {
        if (x.getUB() &amp;lt; y.getLB())
            return ESat.FALSE;
        else if (x.getLB() &amp;gt;= y.getUB())
            return ESat.TRUE;
        else
            return ESat.UNDEFINED;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;elaborated-propagator&#34;&gt;Elaborated propagator&lt;/h4&gt;
&lt;p&gt;The super constructor &lt;code&gt;super(Variable[], PropagatorPriority, boolean);&lt;/code&gt; brings more information.
&lt;code&gt;PropagatorPriority&lt;/code&gt; enables to optimize the propagation engine (low arity for fast propagators is better).
The boolean argument allows to specifies the propagator is incremental.
When set to &lt;code&gt;true&lt;/code&gt;, the method &lt;code&gt;propagate(int varIdx, int mask)&lt;/code&gt; must be implemented.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Note that if many variables are modified between two calls, a non-incremental filtering may be faster (and simpler).&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;propagate(int varIdx, int mask)&lt;/code&gt; defines the incremental filtering.
It is called for every variable &lt;code&gt;vars[varIdx]&lt;/code&gt; whose domain has changed since the last call.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;getPropagationConditions(int vIdx)&lt;/code&gt; enables not to react on every kind of domain modification.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;setPassive()&lt;/code&gt; enables to desactivate the propagator when it is entailed, to save time.
The propagator is automatically reactivated upon backtrack.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;why(...)&lt;/code&gt; explains the filtering, to allow learning.&lt;/p&gt;
&lt;p&gt;Here is an example of how to implement a propagator for &lt;code&gt;X &amp;gt;= Y&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Propagator to apply X &amp;gt;= Y
public final class MyIncrementalPropagator extends Propagator&amp;lt;IntVar&amp;gt; {

    IntVar x, y;

    public MyIncrementalPropagator(IntVar x, IntVar y) {
        super(new IntVar[]{x,y}, PropagatorPriority.BINARY, true);
        this.x = x;
        this.y = y;
    }

    @Override
    public int getPropagationConditions(int vIdx) {
        if (vIdx == 0) {
            // awakes if x gets instantiated or if its upper bound decreases
            return IntEventType.combine(IntEventType.INSTANTIATE, IntEventType.DECUPP);
        } else {
            // awakes if y gets instantiated or if its lower bound increases
            return IntEventType.combine(IntEventType.INSTANTIATE, IntEventType.INCLOW);
        }
    }

    @Override
    public void propagate(int evtmask) throws ContradictionException {
        x.updateLowerBound(y.getLB(), this);
        y.updateUpperBound(x.getUB(), this);
        if (x.getLB() &amp;gt;= y.getUB()) {
            this.setPassive();
        }
    }

    @Override
    public void propagate(int varIdx, int mask) throws ContradictionException {
        if (varIdx == 0) {
            y.updateUpperBound(x.getUB(), this);
        } else {
            x.updateLowerBound(y.getLB(), this);
        }
        if (x.getLB() &amp;gt;= y.getUB()) {
            this.setPassive();
        }
    }

    @Override
    public ESat isEntailed() {
        if (x.getUB() &amp;lt; y.getLB())
            return ESat.FALSE;
        else if (x.getLB() &amp;gt;= y.getUB())
            return ESat.TRUE;
        else
            return ESat.UNDEFINED;
    }

    @Override
    public String toString() {
        return &amp;quot;prop(&amp;quot; + vars[0].getName() + &amp;quot;.GEQ.&amp;quot; + vars[1].getName() + &amp;quot;)&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;idempotency&#34;&gt;Idempotency&lt;/h3&gt;
&lt;p&gt;We distinguish two kinds of propagators:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Necessary&lt;/em&gt; propagators, which ensure constraints to be satisfied.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Redundant&lt;/em&gt; (or &lt;em&gt;Implied&lt;/em&gt;) propagators that come in addition to some necessary propagators in order to get a stronger filtering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Some propagators cannot be idempotent (Lagrangian relaxation, use of randomness, etc.).
For some others, forcing idempotency may be very time consuming.
A redundant propagator does not have to be idempotent but &lt;strong&gt;a necessary propagator should be idempotent&lt;/strong&gt;  .&lt;/p&gt;
&lt;p&gt;Trying to make a propagator idempotent directly may not be straightforward.
We provide three implementation possibilities.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;decomposed&lt;/em&gt;  (recommended) option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Split the original propagator into (partial) propagators so that the fix point is performed through the propagation engine.
For instance, a channeling propagator $A \Leftrightarrow B$ can be decomposed into two propagators $A \Rightarrow B$ and $B \Rightarrow A$.
The propagators can (but do not have to) react on fine events.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;lazy&lt;/em&gt; option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Simply post the propagator twice.
Thus, the fix point is performed through the propagation engine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;em&gt;coarse&lt;/em&gt; option:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the propagator will perform its fix point by itself.
The propagator does not react to fine events.
The coarse filtering algorithm should be surrounded like this:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// In the case of ``SetVar``, replace ``getDomSize()`` by ``getEnvSize()-getKerSize()``.
long size;
do{
  size = 0;
  for(IntVar v:vars){
    size+=v.getDomSize();
  }
  // really update domain variables here
  for(IntVar v:vars){
    size-=v.getDomSize();
  }
}while(size&amp;gt;0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Domain variable modifier returns a boolean valued to &lt;code&gt;true&lt;/code&gt; if the domain variable has been modified.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Designing a search strategy</title>
      <link>https://choco-solver.org/docs/advanced-usages/strategies/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/strategies/</guid>
      <description>
        
        
        &lt;h3 id=&#34;designing-your-own-search-strategy&#34;&gt;Designing your own search strategy&lt;/h3&gt;
&lt;h4 id=&#34;using-selectors&#34;&gt;Using selectors&lt;/h4&gt;
&lt;p&gt;To design your own strategy using &lt;code&gt;Search.intVarSearch&lt;/code&gt;, you simply have to implement
your own variable and value selectors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static IntStrategy intVarSearch(VariableSelector&amp;lt;IntVar&amp;gt; varSelector,
                                    IntValueSelector valSelector,
                                    IntVar... vars)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For instance, to select the first non instantiated variable and assign it to its lower bound:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver s = model.getSolver();
s.setSearch(intVarSearch(
        // variable selector
        (VariableSelector&amp;lt;IntVar&amp;gt;) variables -&amp;gt; {
            for(IntVar v:variables){
                if(!v.isInstantiated()){
                    return v;
                }
            }
            return null;
        },
        // value selector
        (IntValueSelector) var -&amp;gt; var.getLB(),
        // variables to branch on
        x, y
));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: When all variables are instantiated, a &lt;code&gt;VariableSelector&lt;/code&gt; must return &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;from-scratch&#34;&gt;From scratch&lt;/h4&gt;
&lt;p&gt;You can design your own strategy by creating &lt;code&gt;Decision&lt;/code&gt; objects directly as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;s.setSearch(new AbstractStrategy&amp;lt;IntVar&amp;gt;(x,y) {
    // enables to recycle decision objects (good practice)
    PoolManager&amp;lt;IntDecision&amp;gt; pool = new PoolManager();
    @Override
    public Decision getDecision() {
        IntDecision d = pool.getE();
        if(d==null) d = new IntDecision(pool);
        IntVar next = null;
        for(IntVar v:vars){
            if(!v.isInstantiated()){
                next = v; break;
            }
        }
        if(next == null){
            return null;
        }else {
            // next decision is assigning nextVar to its lower bound
            d.set(next,next.getLB(), DecisionOperator.int_eq);
            return d;
        }
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;making-a-decision-greedy&#34;&gt;Making a decision greedy&lt;/h3&gt;
&lt;p&gt;You can make a decision non-refutable by using &lt;code&gt;decision.setRefutable(false)&lt;/code&gt; inside your&lt;/p&gt;
&lt;p&gt;To make an entire search strategy greedy, use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver s = model.getSolver();
s.setSearch(greedySearch(inputOrderLBSearch(x,y,z)));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;large-neighborhood-search-lns&#34;&gt;Large Neighborhood Search (LNS)&lt;/h3&gt;
&lt;h5 id=&#34;defining-its-own-neighborhoods&#34;&gt;Defining its own neighborhoods&lt;/h5&gt;
&lt;p&gt;A presentation of the &lt;a href=&#34;https://choco-solver.org/docs/solving/lns/&#34;&gt;functioning of LNS&lt;/a&gt; was given earlier. It is said that anyone can define its own neighbor, dedicated to the problem solved.
This is achieved by extending either the abstract class &lt;code&gt;IntNeighbor&lt;/code&gt; or by implementing the interface &lt;code&gt;INeighbor&lt;/code&gt;.
The former implements all methods from the latter but &lt;code&gt;void fixSomeVariables() throws ContradictionException;&lt;/code&gt; that defines which variables should be fixed to their value in the last solution.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;INeighbor&lt;/code&gt; forces to implements the following methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Action to perform on a solution. 
 * Typically, storing the current variables’ value.
 */
public void recordSolution() {
    // where `values` and `variables` are class instances
    for (int i = 0; i &amp;lt; variables.length; i++) {
        values[i] = variables[i].getValue();
    }
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Fix some variables to their value in the last solution.
 */
public void fixSomeVariables() throws ContradictionException{
    // An example of random neighbor where a coin is tossed
    // for each variable to choose if it is fixed or not in the current fragment
    for (int i = 0; i &amp;lt; variables.length; i++) {
        if(Math.random() &amp;lt; .9){
            variables[i].instantiateTo(values[i], this);
            // alternatively call: `this.freeze(i);`    
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Relax the number of variables fixed. 
 * Called when no solution was found during a LNS run 
 * (i.e., trapped into a local optimum).
 * if the fragment is based on a class instance (e.g, number of fixed variables)
 * it may be updated there
 */
void restrictLess()
// for instance, the threshold (0.9) previously declare in `fixSomeVariables()`
// can be reduced here
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** 
 * Indicates whether the neighbor is complete, that is, can end.
 * Most of the time, this is related to `restrictLess()`
 */
boolean isSearchComplete()`
// for instance, if the threshold is 0. after a certain number of attempts.
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Search loop</title>
      <link>https://choco-solver.org/docs/advanced-usages/search-loop/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/search-loop/</guid>
      <description>
        
        
        &lt;p&gt;The search loop whichs drives the search is a freely-adapted version PLM .
PLM stands for: Propagate, Learn and Move.
Indeed, the search loop is composed of three parts, each of them with a specific goal.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Propagate: it aims at propagating information throughout the constraint network when a decision is made,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Learn: it aims at ensuring that the search mechanism will avoid (as much as possible) to get back to states that have been explored and proved to be solution-less,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Move: it aims at, unlike the former ones, not pruning the search space but rather exploring it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Any component can be freely implemented and attached to the search loop in order to customize its behavior.
There exists some pre-defined Move and Learn implementations.
One can also define its own Move or Learn implementation.&lt;/p&gt;
&lt;h3 id=&#34;implementing-a-search-loop-component&#34;&gt;Implementing a search loop component&lt;/h3&gt;
&lt;p&gt;A search loop is made of three components, each of them dealing with a specific aspect of the search.
Even if many Move and Learn implementation are already provided, it may be relevant to define its own component.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    The Propagate component is less prone to be modified, it will not be described here.
However, its interface is minimalist and can be easily implemented.
A look to &lt;code&gt;org.chocosolver.solver.search.loop.propagate.PropagateBasic.java&lt;/code&gt; is a good starting point.

&lt;/div&gt;

&lt;p&gt;The two components can be easily set in the &lt;code&gt;Solver&lt;/code&gt; search loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void setMove(Move m)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;The current Move component is replaced by m.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Move getMove()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;The current Move component is returned.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;void setLearn(Learn l)&lt;/code&gt; and &lt;code&gt;Learn getLearn()&lt;/code&gt; are also avaiable.&lt;/p&gt;
&lt;p&gt;Having access to the current &lt;code&gt;Move&lt;/code&gt; (resp. &lt;code&gt;Learn&lt;/code&gt;) component can be useful to combined it with another one.
For instance, the &lt;code&gt;MoveLNS&lt;/code&gt; is activated on a solution and creates a partial solution.
It needs another Move to find the first solution and to complete the partial solution.&lt;/p&gt;
&lt;h4 id=&#34;move&#34;&gt;Move&lt;/h4&gt;
&lt;p&gt;Here is the API of Move:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean extend(SearchLoop searchLoop)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Perform a move when the CSP associated to the current node of the search space is not proven to be not consistent.
It returns true if an extension can be done, false when no more extension is possible.
It has to maintain the correctness of the reversibility of the action by pushing a backup world when needed.
An extension is commonly based on a decision, which may be made on one or many variables.
If a decision is created (thanks to the search strategy), it has to be linked to the previous one.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean repair(SearchLoop searchLoop)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Perform a move when the CSP associated to the current node of the search space is proven to be not consistent.
It returns true if a reparation can be done, false when no more reparation is possible.
It has to backtracking backup worlds when needed, and unlinked useless decisions.
The depth and number of backtracks have to be updated too, and “up branch” search monitors of the search loop have to called
(be careful, when many Move are combined).
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Move getChildMove()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;It returns the child Move or null.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void setChildMove(Move aMove)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;It defined the child Move and erases the previously defined one, if any.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;boolean init()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Called before the search starts, it should initialize the search strategy, if any, and its child Move.
It should return false if something goes wrong (the problem has trivially no solution), true otherwise.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;AbstractStrategy&amp;lt;V&amp;gt; getStrategy()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;It returns the search strategy in use, which may be null if none has been defined.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void setStrategy(AbstractStrategy&amp;lt;V&amp;gt; aStrategy)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;It defines a search strategy and erases the previously defined one, that is, a service which computes and returns decisions.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;org.chocosolver.solver.search.loop.move.MoveBinaryDFS.java&lt;/code&gt; is good starting point to see how a Move is implemented.
It defines a Depth-First Search with binary decisions.&lt;/p&gt;
&lt;h4 id=&#34;learn&#34;&gt;Learn&lt;/h4&gt;
&lt;p&gt;The aim of the component is to make sure that the search mechanism will avoid (as much as possible) to get back to states that have been explored and proved to be solution-less. Here is the API of Learn&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void record(SearchLoop searchLoop)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;It validates and records a new piece of knowledge, that is, the current position is a dead-end.
This is alwasy called *before* calling Move.repair(SearchLoop).
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void forget(SearchLoop searchLoop)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;It forgets some pieces of knowledge.
This is alwasy called *after* calling Move.repair(SearchLoop).
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Explanations</title>
      <link>https://choco-solver.org/docs/advanced-usages/explanations/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/explanations/</guid>
      <description>
        
        
        &lt;p&gt;Choco-solver natively support explanations.
However, no explanation engine is plugged-in by default.&lt;/p&gt;
&lt;h3 id=&#34;principle&#34;&gt;Principle&lt;/h3&gt;
&lt;p&gt;Nogoods and explanations have long been used in various paradigms for improving search.
An explanation records some sufficient information to justify an inference made by the solver (domain reduction, contradiction, etc.).
It is made of a subset of the original propagators of the problem and a subset of decisions applied during search.
Explanations represent the logical chain of inferences made by the solver during propagation in an efficient and usable manner.
In a way, they provide some kind of a trace of the behavior of the solver as any operation needs to be explained.&lt;/p&gt;
&lt;p&gt;The implemented explanation framework is an adapation of the well-konw SAT &lt;a href=&#34;https://en.wikipedia.org/wiki/Conflict-driven_clause_learning&#34;&gt;CDCL algorithm&lt;/a&gt; to discrete constraint solver.
By exploiting the implication graph (that records events, i.e. variables’ modifications), this algorithm is able to derive a new constraint from the events that led to a contradiction.
Once added to the constraint network, this constraint makes possible to “backjump” (non-chronological backtrack) to the appropriate decision in the decision path.&lt;/p&gt;
&lt;p&gt;In CP, learned constraints are denoted “signed-clauses” which is a disjunction of signed-literals, i.e. membership unary constraints : $\bigvee_{i=0}^{n}X_i \in D_i$
where $X_i$ are variables and $D_i$ a set of values.
A signed-clause is satisfied when at least one signed-literal is satisfied.&lt;/p&gt;
&lt;p&gt;The current explanation engine is coded to be &lt;em&gt;Asynchronous, Reverse, Low-intrusive and Lazy&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;Asynchronous:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Explanations are not computed during the propagation.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reverse:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Explanations are computed in a bottom-up way, from the conflict to the first event generated, *keeping* only relevant events to compute the explanation of the conflict.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Low-intrusive:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Basically, propagators need to implement only one method to furnish a convenient explanation schema.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lazy:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Explanations are computed on request.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do so, all events are stored during the descent to a conflict/solution, and are then evaluated and kept if relevant, to get the explanation.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    In CP, CDCL algorithm requires that each constraint of a problem can be explained. Even though a default explanation function for any constraint, dedicated functions offers better performances.
In Choco-solver a few set of constraints is equipped with dedicated explanation function (unary constraints, binary and ternary, sum and scalar).

&lt;/div&gt;

&lt;h3 id=&#34;computing-explanations&#34;&gt;Computing explanations&lt;/h3&gt;
&lt;p&gt;When a contradiction occurs during propagation, it can only be thrown by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a propagator which detects unsatisfiability, based on the current domain of its variables;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;or a variable whom domain became empty.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Consequently, in addition to causes, variables can also explain the current state of their domain.
Computing the explanation of a failure consists in going up in the stack of all events generated in the current branch of the search tree and filtering the one relative to the conflict.
The entry point is either the not satisfiable propagator or the empty variable.&lt;/p&gt;
&lt;p&gt;Each propagator embeds its own explanation algorithm which relies on the relation it defines over variables.&lt;/p&gt;
&lt;h3 id=&#34;explanations-for-the-system&#34;&gt;Explanations for the system&lt;/h3&gt;
&lt;p&gt;Explanations for the system, which try to reduce the search space, differ from the ones giving feedback to a user about the unsatisfiability of its model.
Both rely on the capacity of the explanation engine to motivate a failure, during the search form system explanations and once the search is complete for user ones.&lt;/p&gt;
&lt;h4 id=&#34;learning-signed-clauses&#34;&gt;Learning signed-clauses&lt;/h4&gt;
&lt;p&gt;When learning is plugged-in, the search is hacked in the following way.
On a failure, the implication graph is analyzed in order to build a signed-clause and to define the decision to jump back to it.
Decisions from the current one to the return decision (excluded) are erased.
Then, the signed-clause is added to the constraint network and automatically dominates decision refutation; then the search goes on.
If the explanation jumps back to the root node, the problem is proven to have no solution and search stops.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;API&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setLearningSignedClauses();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;solver&lt;/em&gt;: the solver to explain.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See Settings to configure learning algorithm.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Ibex</title>
      <link>https://choco-solver.org/docs/advanced-usages/ibex/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/ibex/</guid>
      <description>
        
        
        &lt;p&gt;To manage continuous constraints with Choco, an interface with &lt;a href=&#34;http://www.ibex-lib.org/&#34;&gt;Ibex&lt;/a&gt; has been done.
It needs this library to be installed on your system.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“IBEX is a C++ library for constraint processing over real numbers.
It provides reliable algorithms for handling non-linear constraints.
In particular, round off errors are also taken into account.
It is based on interval arithmetic and affine arithmetic.”
– &lt;a href=&#34;http://www.ibex-lib.org/&#34;&gt;http://www.ibex-lib.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;installing-ibex&#34;&gt;Installing Ibex&lt;/h3&gt;
&lt;p&gt;See the &lt;a href=&#34;http://www.ibex-lib.org/doc/install.html&#34;&gt;installation instructions&lt;/a&gt; of Ibex to complied Ibex on your system.
More specially, take a look at &lt;a href=&#34;http://www.ibex-lib.org/doc/install.html#installation-as-a-dynamic-library&#34;&gt;Installation as a dynamic library&lt;/a&gt;
Do not forget to add the &lt;code&gt;--with-java-package=org.chocosolver.solver.constraints.real&lt;/code&gt; configuration option.&lt;/p&gt;
&lt;h3 id=&#34;using-ibex&#34;&gt;Using Ibex&lt;/h3&gt;
&lt;p&gt;Once the installation is completed, the JVM needs to know where Ibex is installed to fully benefit from the Choco-Ibex bridge and declare real variables and constraints.
This can be done either with an environment variable of by adding &lt;code&gt;-Djava.library.path=path/to/ibex/lib&lt;/code&gt; to the JVM arguments.
The path /path/to/ibex/lib points to the lib directory of the Ibex installation directory.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: SAT</title>
      <link>https://choco-solver.org/docs/advanced-usages/sat/</link>
      <pubDate>Tue, 06 Apr 2021 14:14:31 +0200</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/sat/</guid>
      <description>
        
        
        &lt;p&gt;Choco-solver embeds a SAT solver, which can optionally be used to handle
declared clauses in a mixed SAT and CP problem,
and which is also used to handle no-goods.
These uses do not make the underlying SAT solver directly accessible.&lt;/p&gt;
&lt;h3 id=&#34;a-java-transposition-of-minisat&#34;&gt;A Java transposition of MiniSat&lt;/h3&gt;
&lt;p&gt;Before version 4.10.7, Choco-solver embedded only an incomplete version of a SAT solver:
only the part concerning clause propagation had been transposed.
Since version 4.10.7, the solver is complete.
It is simply a Java version of &lt;a href=&#34;http://minisat.se/MiniSat.html&#34;&gt;MiniSat&lt;/a&gt;
(released under the MIT licence).
For read/write reasons in the internal structures,
this solution was preferred to one based on an additional dependency.&lt;/p&gt;


&lt;div class=&#34;alert alert-secondary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    If you are looking to use a SAT solver, we can only recommend dedicated libraries:
&lt;a href=&#34;https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Offline_SAT_solvers&#34;&gt;Offline_SAT_solvers&lt;/a&gt;.

&lt;/div&gt;

&lt;p&gt;If you still want to use this implementation, here is an example of its use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MiniSat sat = new MiniSat();
int a = sat.newVariable();
int b = sat.newVariable();
sat.addClause(MiniSat.makeLiteral(a), MiniSat.neg(MiniSat.makeLiteral(b)));
MiniSat.Boolean ret = sat.solve();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you can parse a CNF file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;MiniSat solver = new MiniSat();
solver.parse(&amp;quot;/path/to/instance.cnf&amp;quot;);
MiniSat.Boolean ret = solver.solve();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if you want to mix SAT and CP, having access to the SAT solver might be helpful.&lt;/p&gt;
&lt;h3 id=&#34;binding-cp-variables-to-sat-variables&#34;&gt;Binding CP variables to SAT variables&lt;/h3&gt;
&lt;p&gt;Facilities are given to link a &lt;code&gt;BoolVar&lt;/code&gt; to its equivalent on the SAT side.
This is achieved using &lt;code&gt;satVar()&lt;/code&gt; API.
Calling this method on an instance of &lt;code&gt;BoolVar&lt;/code&gt; will create (or return) the
variable in the SAT solver attached to a &lt;code&gt;Solver&lt;/code&gt; and return its id (an &lt;code&gt;int&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Model model  = new Model();
BoolVar a = m.boolVar(&amp;quot;a&amp;quot;);
BoolVar b = m.boolVar(&amp;quot;b&amp;quot;);
int sa = a.satVar();
int sb = b.satVar();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, it is possible to declare a clause using these SAT variables.
However, this requires the positive (&lt;code&gt;lit(sb)&lt;/code&gt;) and negative (&lt;code&gt;neg(sa)&lt;/code&gt;) literals to be entered.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// a is true implies b is true (a is false or b is true)
model.addClause(model.neg(sa), model.lit(sb));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One can also want to bind an integer variable to SAT variable.
In that case, a relationship is needed; this is achieved thanks to some binary relational expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Model model  = new Model();
IntVar c = m.intVar(&amp;quot;c&amp;quot;, 1, 3);
IntVar d = m.intVar(&amp;quot;d&amp;quot;, 2, 4);
int sc = c.eq(2).satVar();
int sd = d.le(3).satVar();
// c is equal to 2 and d is less than or equal to 3
model.addClause(model.neg(sc), model.lit(sd))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can also be achieved by using views and reifications.&lt;/p&gt;
&lt;h4 id=&#34;go-off-the-beaten-track&#34;&gt;Go off the beaten track&lt;/h4&gt;
&lt;p&gt;It is also possible to declare its own links, by implementing the &lt;code&gt;Literalizer&lt;/code&gt; interface.
Doing so, it is possible to bind manually a relationship to a SAT variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Model model  = new Model();
IntVar e = m.setVar(&amp;quot;e&amp;quot;, new int[]{}, new int[]{1,2,3});
// link the membership of the value 2 to the set e
int se = model.satVar(v, new SetInLit(s, 2));
// then declare clauses
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code&gt;SetInLit&lt;/code&gt; is defined as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static org.chocosolver.sat.MiniSat.sgn;
import static org.chocosolver.sat.MiniSat.var;

class SetInLit implements Literalizer {
    public final SetVar cpVar;
    public final int val;
    public int satVar;

    public SetInLit(SetVar cpVar, int val) {
        this.cpVar = cpVar;
        this.val = val;
        this.satVar = -1;
    }

    /**
     * Set the SAT variable
     */
    @Override
    public void svar(int svar) {
        if (satVar == -1) {
            this.satVar = svar;
        } else {
            throw new UnsupportedOperationException(&amp;quot;Overriding Literalizer&#39;s satVar is forbidden&amp;quot;);
        }
    }

    /**
     * @return this SAT variable
     */
    @Override
    public int svar() {
        return satVar;
    }

    /**
     * @return this CP variable
     */
    @Override
    public Variable cvar() {
        return cpVar;
    }

    /**                                                 
     * @return {@code true} if this will fix its literal
     */                                                 
    @Override
    public boolean canReact() {
        return cpVar.getLB().contains(val) || !cpVar.getUB().contains(val);
    }

    /**                                                     
     * Turns an event into a literal and returns it.        
     *                                                      
     * @return the literal to enqueue in SAT                
     */                                                     
    @Override
    public int toLit() {
        return MiniSat.makeLiteral(satVar, cpVar.getLB().contains(val));
    }

    /**                                                                                                      
     * Turns an event from SAT side (in the form of a literal) to an event in CP side.                       
     * Actually, it is expected that the event is directly applied, that&#39;s why a contradiction may be thrown.
     *                                                                                                       
     * @param lit   the literal                                                                              
     * @param cause cause (for CP propagation purpose)                                                       
     * @return {@code true} if the CP variable has been modified                                             
     * @throws ContradictionException if the conversion leads to a failure                                   
     */                                                                                                      
    @Override
    public boolean toEvent(int lit, ICause cause) throws ContradictionException {
        assert satVar == var(lit);
        if (sgn(lit)) {
            return cpVar.force(val, cause);
        } else {
            return cpVar.remove(val, cause);
        }
    }

    /**                                                 
     * @return {@code true} if this relationship holds
     */                                                 
    @Override
    public boolean check(boolean sign) {
        return sign ? cpVar.getLB().contains(val) : !cpVar.getUB().contains(val);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof SetInLit)) return false;
        SetInLit setInLit = (SetInLit) o;
        return val == setInLit.val &amp;amp;&amp;amp; cpVar.equals(setInLit.cpVar);
    }

    @Override
    public int hashCode() {
        return Objects.hash(cpVar, val);
    }
}
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Miscellaneous</title>
      <link>https://choco-solver.org/docs/advanced-usages/miscellaneous/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/advanced-usages/miscellaneous/</guid>
      <description>
        
        
        &lt;h3 id=&#34;search-monitors&#34;&gt;Search monitors&lt;/h3&gt;
&lt;h4 id=&#34;principle&#34;&gt;Principle&lt;/h4&gt;
&lt;p&gt;A search monitor is an observer of the resolver.
It gives user access before and after executing each main step of the solving process:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;initialize: when the solving process starts and the initial propagation is run,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;open node: when a decision is computed,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;down branch: on going down in the tree search applying or refuting a decision,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;up branch: on going up in the tree search to reconsider a decision,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;solution: when a solution is got,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;restart search: when the search is restarted to a previous node, commonly the root node,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;close: when the solving process ends,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;contradiction: on a failure,&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the accurate search monitor, one can easily observe with the resolver, from pretty printing of a solution to learning nogoods from restart, or many other actions.&lt;/p&gt;
&lt;p&gt;The interfaces to implement are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorInitialize&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorOpenNode&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorDownBranch&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorUpBranch&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorSolution&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorRestart&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorContradiction&lt;/code&gt;,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IMonitorClose&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Most of them gives the opportunity to do something before and after a step. The other ones are called after a step.&lt;/p&gt;
&lt;p&gt;Simple example to print every solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.plugMonitor(new IMonitorSolution() {
    @Override
    public void onSolution() {
        System.out.println(&amp;quot;x = &amp;quot;+x.getValue());
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Java 8 style:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solver s = model.getSolver();
s.plugMonitor((IMonitorSolution) () -&amp;gt; {System.out.println(&amp;quot;x = &amp;quot;+x.getValue());});
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;settings&#34;&gt;Settings&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Settings&lt;/code&gt; object is attached to each &lt;code&gt;Model&lt;/code&gt;.
It declares default behavior for various purposes: from general purpose (such as the welcome message), modelling purpose (such as enabling views) or solving purpose (such as the search binder).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Settings&lt;/code&gt; is a &lt;em&gt;factory design pattern&lt;/em&gt; and provides two default settings: &lt;code&gt;Settings.dev()&lt;/code&gt; and &lt;code&gt;Settings.prod()&lt;/code&gt; which offers configurations adapted to a development or production environment. These can then be modified via setters.&lt;/p&gt;
&lt;p&gt;Settings are declared in a &lt;code&gt;Model&lt;/code&gt; constructor.
Settings are not immutable but modifying value after &lt;code&gt;Model&lt;/code&gt; construction can lead to unexpected behavior.&lt;/p&gt;
&lt;h2 id=&#34;extensions-of-choco&#34;&gt;Extensions of Choco&lt;/h2&gt;
&lt;h3 id=&#34;choco-parsers&#34;&gt;choco-parsers&lt;/h3&gt;
&lt;p&gt;choco-parsers is an extension of Choco 4. It provides a parser for the FlatZinc language, a low-level solver input language that is the target language for MiniZinc.
This module follows the flatzinc standards that are used for the annual MiniZinc challenge. It only supports integer variables.
You will find it at &lt;a href=&#34;https://github.com/chocoteam/choco-parsers&#34;&gt;https://github.com/chocoteam/choco-parsers&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;choco-graph&#34;&gt;choco-graph&lt;/h3&gt;
&lt;p&gt;choco-graph is a Choco 4 module which allows to search for a graph, which may be subject to graph constraints.
The domain of a graph variable G is a graph interval in the form [G_lb,G_ub].
G_lb is the graph representing vertices and edges which must belong to any single solution whereas G_ub is the graph representing vertices and edges which may belong to one solution.
Therefore, any value G_v must satisfy the graph inclusion “G_lb subgraph of G_v subgraph of  G_ub”.
One may see a strong connection with set variables.
A graph variable can be subject to graph constraints to ensure global graph properties (e.g. connectedness, acyclicity) and channeling constraints to link the graph variable with some other binary, integer or set variables.
The solving process consists of removing nodes and edges from G_ub and adding some others to G_lb until having G_lb = G_ub, i.e. until G gets instantiated.
These operations stem from both constraint propagation and search. The benefits of graph variables stem from modeling convenience and performance.&lt;/p&gt;
&lt;p&gt;This extension has documentation. You will find it at &lt;a href=&#34;https://github.com/chocoteam/choco-graph&#34;&gt;https://github.com/chocoteam/choco-graph&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;choco-gui&#34;&gt;choco-gui&lt;/h3&gt;
&lt;p&gt;choco-gui is an extension of Choco 4.
It provides a Graphical User Interface with various views which can be simply plugged on any Choco Model object.
You will find it at &lt;a href=&#34;https://github.com/chocoteam/choco-gui&#34;&gt;https://github.com/chocoteam/choco-gui&lt;/a&gt;&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
