<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Choco-solver – Solving</title>
    <link>https://choco-solver.org/docs/solving/</link>
    <description>Recent content in Solving on Choco-solver</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 07 Jan 2020 16:08:22 +0100</lastBuildDate>
    
	  <atom:link href="https://choco-solver.org/docs/solving/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Lauching the resolution process</title>
      <link>https://choco-solver.org/docs/solving/solving/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/solving/</guid>
      <description>
        
        
        &lt;h2 id=&#34;finding-one-solution&#34;&gt;Finding one solution&lt;/h2&gt;
&lt;p&gt;A call to &lt;code&gt;solver.solve()&lt;/code&gt; launches a resolution which stops on the first solution found, if any:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(solver.solve()){
    // do something, e.g. print out variable values
}else if(solver.hasReachedLimit()){
    System.out.println(&amp;quot;The solver could not find a solution
                        nor prove that none exists in the given limits&amp;quot;);
}else {
    System.out.println(&amp;quot;The solver has proved the problem has no solution&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;solver.solve()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, then a solution has been found and each variable is instantiated to a value.
Otherwise, two cases must be considered:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A limit has been declared and reached (&lt;code&gt;solver.hasReachedLimit()&lt;/code&gt; returns true).
There may be a solution, but the solver has not been able to find it in the given limit
or there is no solution but the solver has not been able to prove it (i.e., to close to search tree) in the given limit.
The resolution process stops in no particular place in the search tree.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No limit has been declared or reached: The problem has no solution and the solver has proved it.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;enumerating-all-solutions&#34;&gt;Enumerating all solutions&lt;/h2&gt;
&lt;p&gt;You can enumerate all solutions of a problem with a simple while loop as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while(solver.solve()){
    // do something, e.g. print out variable values
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the enumeration, the solver closes the search tree and variables are no longer instantiated to a value.&lt;/p&gt;
&lt;h2 id=&#34;optimization&#34;&gt;Optimization&lt;/h2&gt;
&lt;p&gt;In Constraint-Programming, optimization is done by computing improving solutions, until reaching an optimum.
Therefore, it can be seen as solving multiple times the model while adding constraints on the fly to prevent the solver from computing dominated solutions.&lt;/p&gt;
&lt;h3 id=&#34;mono-objective-optimization&#34;&gt;Mono-objective optimization&lt;/h3&gt;
&lt;p&gt;The optimization process is the following: anytime a solution is found, the value of the objective variable is stored and a &lt;em&gt;cut&lt;/em&gt; is posted.
The cut is an additional constraint which states that the next solution must be (strictly) better than the current one.
To solve an optimization problem, you must specify which variable to optimize and in which direction:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// to maximize X
model.setObjective(Model.MAXIMIZE, X);
// or model.setObjective(Model.MINIMIZE, X); to minimize X
while(solver.solve()){
    // an improving solution has been found
}
// the last solution found was optimal (if search completed)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use custom cuts by overriding the default cut behavior.
The &lt;em&gt;cut computer&lt;/em&gt; function defines how the cut should bound the objective variable.
The input &lt;em&gt;number&lt;/em&gt; is the best solution value found so far, the output &lt;em&gt;number&lt;/em&gt; define the new bound.
When maximizing (resp. minimizing) a problem, the cut limits the lower bound (resp. upper bound) of the objective variable.
For instance, one may want to indicate that the value of the objective variable is the next solution should be
greater than or equal to the best value + 10&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ObjectiveManager&amp;lt;IntVar, Integer&amp;gt; oman = solver.getObjectiveManager();
oman.setCutComputer(n -&amp;gt; n - 10);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;multi-objective-optimization&#34;&gt;Multi-objective optimization&lt;/h3&gt;
&lt;p&gt;If you have multiple objective to optimize, you have several options. First, you may aggregate them in a function so that you end up with only one objective variable. Second, you can solve the problem multiple times, each one optimizing one variable and possibly fixing some bounds on the other. Third, you can enumerate solutions (without defining any objective) and add constraints on the fly to prevent search from finding dominated solutions. This is done by the ParetoOptimizer object which does the following:
Anytime a solution is found, a constraint is posted which states that at least one of the objective variables must be strictly better:
Such as $(X_0 &amp;lt; b_0 \lor X_1 &amp;lt; b_1 \lor \ldots \lor X_n &amp;lt; b_n)$ where $X_i$ is the ith objective variable and $b_i$ its value.&lt;/p&gt;
&lt;p&gt;Here is a simple example on how to use the ParetoOptimizer to optimize two variables (a and b):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// simple model
Model model = new Model();
IntVar a = model.intVar(&amp;quot;a&amp;quot;, 0, 2, false);
IntVar b = model.intVar(&amp;quot;b&amp;quot;, 0, 2, false);
IntVar c = model.intVar(&amp;quot;c&amp;quot;, 0, 2, false);
model.arithm(a, &amp;quot;+&amp;quot;, b, &amp;quot;=&amp;quot;, c).post();

// create an object that will store the best solutions and remove dominated ones
ParetoOptimizer po = new ParetoOptimizer(Model.MAXIMIZE,new IntVar[]{a,b});
Solver solver = model.getSolver();
solver.plugMonitor(po);

// optimization
while(solver.solve());

// retrieve the pareto front
List&amp;lt;Solution&amp;gt; paretoFront = po.getParetoFront();
System.out.println(&amp;quot;The pareto front has &amp;quot;+paretoFront.size()+&amp;quot; solutions : &amp;quot;);
for(Solution s:paretoFront){
        System.out.println(&amp;quot;a = &amp;quot;+s.getIntVal(a)+&amp;quot; and b = &amp;quot;+s.getIntVal(b));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: All objectives must be optimized on the same direction (either minimization or maximization).&lt;/p&gt;
&lt;h2 id=&#34;propagation&#34;&gt;Propagation&lt;/h2&gt;
&lt;p&gt;One may want to propagate all constraints without search for a solution.
This can be achieved by calling &lt;code&gt;solver.propagate()&lt;/code&gt;.
This method runs, in turn, the domain reduction algorithms of the constraints until it reaches a fix point.
It may throw a &lt;code&gt;ContradictionException&lt;/code&gt; if a contradiction occurs.
In that case, the propagation engine must be flushed calling &lt;code&gt;solver.getEngine().flush()&lt;/code&gt;
to ensure there is no pending events.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: If there are still pending events in the propagation engine, the propagation may results in unexpected results.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Dealing with solutions</title>
      <link>https://choco-solver.org/docs/solving/solutions/</link>
      <pubDate>Fri, 06 Mar 2020 16:42:00 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/solutions/</guid>
      <description>
        
        
        &lt;h2 id=&#34;recording-solutions&#34;&gt;Recording solutions&lt;/h2&gt;
&lt;p&gt;A solution can be stored through a &lt;code&gt;Solution&lt;/code&gt; object which maps every variable with its current value.
It can be created as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solution solution = new Solution(model);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;reducing-data-recorded&#34;&gt;Reducing data recorded&lt;/h3&gt;
&lt;p&gt;By default, a solution records the value of every variable, but you can specify a smaller scope in the &lt;code&gt;Solution&lt;/code&gt; constructor.&lt;/p&gt;
&lt;p&gt;Let &lt;code&gt;X&lt;/code&gt; be the set of decision variables and &lt;code&gt;Y&lt;/code&gt; another variable set that you need to store.
To record other variables (e.g. an objective variables) you have two options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Declare them in the search strategy using a complementary strategy&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.set(strategy(X),strategy(Y)).
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Specify which variables to store in the solution constructor&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solution solution = new Solution(model(), ArrayUtils.append(X,Y));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can record the last solution found as follows :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solution solution = new Solution(model);
while (solver.solve()) {
    solution.record();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use a monitor as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solution solution = new Solution(model);
solver.plugMonitor(new IMonitorSolution() {
      @Override
      public void onSolution() {
          s.record();
      }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or with lambdas:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solution solution = new Solution(model);
solver.plugMonitor((IMonitorSolution) () -&amp;gt; s.record());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the solution is erased on each new recording.
To store all solutions, you need to create one new solution object for each solution.&lt;/p&gt;
&lt;p&gt;You can then access the value of a variable in a solution as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int val = s.getIntVal(Y[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The solution object can be used to store all variables in Choco Solver (binaries, integers, sets and reals)&lt;/p&gt;
&lt;h2 id=&#34;accessing-variable-value&#34;&gt;Accessing variable value&lt;/h2&gt;
&lt;p&gt;The value of a variable can be accessed directly through the &lt;code&gt;getValue()&lt;/code&gt; method only once the variable is instantiated, i.e. the value has been computed
(call &lt;code&gt;isInstantiated()&lt;/code&gt; to check it). Otherwise, the lower bound is returned (or an exception is thrown if &lt;code&gt;-ea&lt;/code&gt; is set as JVM argument).&lt;/p&gt;
&lt;p&gt;For instance, the following code will return the lower bound of &lt;code&gt;var&lt;/code&gt; (or an assertion exception) since the resolution has not begun:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int val = var.getValue();
solver.solve();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the other hand, the following code may return the lower bound of &lt;code&gt;var&lt;/code&gt; (or an assertion exception) if no solution could be found (unsat problem or time limit reached):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.solve();
int val = var.getValue();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The correct approach to get the value of a variable &lt;code&gt;var&lt;/code&gt; in a solution is :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if(solver.solve()){
    int val = var.getValue();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In optimization, you can print its value in each solution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while(solver.solve()){
    System.out.println(variable.getValue());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last printed value corresponds to the one in the best solution found.&lt;/p&gt;
&lt;p&gt;However, the following code does &lt;em&gt;NOT&lt;/em&gt; display the best solution found:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;while(solver.solve()){
    System.out.println(variable.getValue());
}
System.out.println(&amp;quot;best solution found: &amp;quot;+variable.getValue());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because it is outside the while loop, this code is reached once the search tree has been closed.
It does not correspond to a &lt;em&gt;solution state&lt;/em&gt; and therefore variable is no longer instantiated at this stage.
To use solutions afterward, you need to record them using &lt;code&gt;Solution&lt;/code&gt; objects.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Search Strategies</title>
      <link>https://choco-solver.org/docs/solving/strategies/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/strategies/</guid>
      <description>
        
        
        &lt;p&gt;The search space induced by variable domains is equal to $S=|d_1|\times|d_2|\times\cdots\times|d_n|$ where $d_i$ is the domain of the $i^{th}$ variable.
Most of the time (not to say always), constraint propagation is not sufficient to build a solution, that is, to remove all values but one from variable domains.
Thus, the search space needs to be explored using one or more &lt;em&gt;search strategies&lt;/em&gt;.
A search strategy defines how to explore the search space by computing &lt;em&gt;decisions&lt;/em&gt;.
A decision involves a variables, a value and an operator, e.g. $x = 5$, and triggers new constraint propagation.
Decisions are computed and applied until all the variables are instantiated, that is, a solution has been found, or a failure has been detected (backtrack occurs).
Choco 4.10.2 builds a binary search tree: each decision can be refuted (if $x = 5$ leads to no solution, then $x \neq 5$ is applied).
The classical search is based on &lt;a href=&#34;http://en.wikipedia.org/wiki/Depth-first_search&#34;&gt;Depth First Search&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: There are many ways to explore the search space and this steps should not be overlooked.
Search strategies or heuristics have a strong impact on resolution performances.
Thus, it is strongly recommended to adapt the search space exploration to the problem treated.&lt;/p&gt;
&lt;h3 id=&#34;default-search-strategy&#34;&gt;Default search strategy&lt;/h3&gt;
&lt;p&gt;If no search strategy is specified to the resolver, Choco 4 will rely on the default one (defined by a &lt;code&gt;defaultSearch&lt;/code&gt; in &lt;code&gt;Search&lt;/code&gt;).
In many cases, this strategy will not be sufficient to produce satisfying performances and it will be necessary to specify a dedicated strategy, using &lt;code&gt;solver.setSearch(...)&lt;/code&gt;.
The default search strategy splits variables according to their type and defines specific search strategies for each type that are sequentially applied:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;integer variables and boolean variables : &lt;code&gt;intVarSearch(ivars)&lt;/code&gt; (calls &lt;code&gt;domOverWDegSearch&lt;/code&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set variables: &lt;code&gt;setVarSearch(svars)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;real variables &lt;code&gt;realVarSearch(rvars)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;objective variable, if any: lower bound or upper bound, depending on the optimization direction&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that lastConflict is also plugged-in.&lt;/p&gt;
&lt;h3 id=&#34;specifying-a-search-strategy&#34;&gt;Specifying a search strategy&lt;/h3&gt;
&lt;p&gt;You may specify a search strategy to the resolver by using &lt;code&gt;solver.setSearch(...)&lt;/code&gt; method as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import static org.chocosolver.solver.search.strategy.Search.*;

// to use the default SetVar search on mySetVars
Solver s = model.getSolver();
s.setSearch(setVarSearch(mySetVars));

// to use activity based search on myIntVars
Solver s = model.getSolver();
s.setSearch(activityBasedSearch(myIntVars));

// to use activity based search on myIntVars
// then the default SetValSelectorFactoryVar search on mySetVars
Solver s = model.getSolver();
s.setSearch(activityBasedSearch(myIntVars), setVarSearch(mySetVars));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: Search strategies generally hold on some particular variable kinds only (e.g. integers, sets, etc.).&lt;/p&gt;
&lt;h4 id=&#34;example&#34;&gt;Example&lt;/h4&gt;
&lt;p&gt;Let us consider we have two integer variables &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and we want our strategy to select
the variable of smallest domain and assign it to its lower bound.
There are several ways to achieve this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1) verbose approach using usual imports

import org.chocosolver.solver.search.strategy.Search;
import org.chocosolver.solver.search.strategy.assignments.DecisionOperator;
import org.chocosolver.solver.search.strategy.selectors.values.*;
import org.chocosolver.solver.search.strategy.selectors.variables.*;


    Solver s = model.getSolver();
    s.setSearch(Search.intVarSearch(
                    // selects the variable of smallest domain size
                    new FirstFail(model),
                    // selects the smallest domain value (lower bound)
                    new IntDomainMin(),
                    // apply equality (var = val)
                    DecisionOperator.int_eq,
                    // variables to branch on
                    x, y
    ));
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 2) Shorter approach : Use a static import for Search
// and do not specify the operator (equality by default)

import static org.chocosolver.solver.search.strategy.Search.*;

import org.chocosolver.solver.search.strategy.assignments.DecisionOperator;
import org.chocosolver.solver.search.strategy.selectors.values.*;
import org.chocosolver.solver.search.strategy.selectors.variables.*;


    Solver s = model.getSolver();
    s.setSearch(intVarSearch(
                    // selects the variable of smallest domain size
                    new FirstFail(model),
                    // selects the smallest domain value (lower bound)
                    new IntDomainMin(),
                    // variables to branch on
                    x, y
    ));


// 3) Shortest approach using built-in strategies imports

import static org.chocosolver.solver.search.strategy.Search.*;

    Solver s = model.getSolver();
    s.setSearch(minDomLBSearch(x, y));
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;list-of-available-search-strategy&#34;&gt;List of available search strategy&lt;/h3&gt;
&lt;p&gt;Most available search strategies are listed in &lt;code&gt;Search&lt;/code&gt;.
This factory enables you to create search strategies using static methods.
Most search strategies rely on :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;variable selectors (see package &lt;code&gt;org.chocosolver.solver.search.strategy.selectors.values&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;value selectors (see package &lt;code&gt;org.chocosolver.solver.search.strategy.selectors.variables&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;operators (see &lt;code&gt;DecisionOperator&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Search&lt;/code&gt; is not exhaustive, look at the selectors package to see learn more search possibilities.&lt;/p&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    Note that some strategies are &lt;em&gt;dynamic&lt;/em&gt; and might work more efficiently when combined with a &lt;a href=&#34;https://choco-solver.org/docs/solving/restarts/&#34;&gt;restart policy&lt;/a&gt;.

&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: Statistics</title>
      <link>https://choco-solver.org/docs/solving/statistics/</link>
      <pubDate>Fri, 06 Mar 2020 17:54:44 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/statistics/</guid>
      <description>
        
        
        &lt;p&gt;Resolution data are available in the &lt;code&gt;Solver&lt;/code&gt; object, whose default output is &lt;code&gt;System.out&lt;/code&gt;.
It centralises widely used methods to have comprehensive feedback about the resolution process.
There are two types of methods: those who need to be called &lt;strong&gt;before&lt;/strong&gt; the resolution, with a prefix show, and those who need to called &lt;strong&gt;after&lt;/strong&gt; the resolution, with a prefix print.&lt;/p&gt;
&lt;p&gt;For instance, one can indicate to print the solutions all resolution long:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.showSolutions();
solver.findAllSolutions();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or to print the search statistics once the search ends:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.solve();
solver.printStatistics();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On a call to &lt;code&gt;solver.printVersion()&lt;/code&gt;, the following message will be printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;** Choco 4.10.2 (2019-10) : Constraint Programming Solver, Copyright (c) 2010-2019
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;resolution-measures&#34;&gt;Resolution measures&lt;/h3&gt;
&lt;p&gt;On a call to &lt;code&gt;solver.printStatistics()&lt;/code&gt;, the following message will be printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;- [ Search complete - [ No solution | {0} solution(s) found ]
  | Incomplete search - [ Limit reached | Unexpected interruption ] ].
   Solutions: {0}
[  Maximize = {1}  ]
[  Minimize = {2}  ]
   Building time : {3}s
   Resolution : {6}s
   Nodes: {7} ({7}/{6} n/s)
   Backtracks: {8}
   Fails: {9}
   Restarts: {10}
   Max depth: {11}
   Variables: {12}
   Constraints: {13}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Curly brackets &lt;em&gt;{instruction | }&lt;/em&gt; indicate alternative instructions&lt;/p&gt;
&lt;p&gt;Brackets &lt;em&gt;[instruction]&lt;/em&gt; indicate an optional instruction.&lt;/p&gt;
&lt;p&gt;If the search terminates, the message “Search complete” appears on the first line, followed with either the number of solutions found or the message “No solution”.
&lt;code&gt;Maximize&lt;/code&gt; –resp. &lt;code&gt;Minimize&lt;/code&gt;– indicates the best known value for the objective variable before exiting when an (single) objective has been defined.&lt;/p&gt;
&lt;p&gt;Curly braces &lt;em&gt;{value}&lt;/em&gt; indicate search statistics:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;number of solutions found&lt;/li&gt;
&lt;li&gt;objective value in maximization&lt;/li&gt;
&lt;li&gt;objective value in minimization&lt;/li&gt;
&lt;li&gt;building time in second (from &lt;code&gt;new Model()&lt;/code&gt; to &lt;code&gt;solve()&lt;/code&gt; or equivalent)&lt;/li&gt;
&lt;li&gt;initialisation time in second (before initial propagation)&lt;/li&gt;
&lt;li&gt;initial propagation time in second&lt;/li&gt;
&lt;li&gt;resolution time in second (from &lt;code&gt;new Model()&lt;/code&gt; till now)&lt;/li&gt;
&lt;li&gt;number of nodes in the binary tree search : one for the root node and between one and two for each decision (two when the decision has been refuted)&lt;/li&gt;
&lt;li&gt;number of backtracks achieved&lt;/li&gt;
&lt;li&gt;number of failures that occurred (conflict number)&lt;/li&gt;
&lt;li&gt;number of restarts operated&lt;/li&gt;
&lt;li&gt;maximum depth reached in the binary tree search&lt;/li&gt;
&lt;li&gt;number of variables in the model&lt;/li&gt;
&lt;li&gt;number of constraints in the model&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;If the resolution process reached a limit before ending &lt;em&gt;naturally&lt;/em&gt;, the title of the message is set to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;- Incomplete search - Limit reached.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The body of the message remains the same. The message is formatted thanks to the &lt;code&gt;IMeasureRecorder&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;showing-solutions&#34;&gt;Showing solutions&lt;/h3&gt;
&lt;p&gt;On a call to &lt;code&gt;solver.showSolutions()&lt;/code&gt;, on each solution the following message will be printed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;{0} Solutions, [Maximize = {1}][Minimize = {2}], Resolution {6}s, {7} Nodes, \\
                                    {8} Backtracks, {9} Fails, {10} Restarts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;followed by one line exposing the value of each decision variables (those involved in the search strategy).&lt;/p&gt;
&lt;h3 id=&#34;showing-decisions&#34;&gt;Showing decisions&lt;/h3&gt;
&lt;p&gt;On a call to &lt;code&gt;solver.showDecisions()&lt;/code&gt;, on each node of the search tree a message will be printed indicating which decision is applied.
The message is prefixed by as many “.” as nodes in the current branch of the search tree.
A decision is prefixed with &lt;code&gt;[R]&lt;/code&gt; and a refutation is prefixed by &lt;code&gt;[L]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;..[L]x  ==  1 (0) //X = [0,5] Y = [0,6] ...
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Warning&lt;/h4&gt;

    A call to &lt;code&gt;solver.showDecisions()&lt;/code&gt; prints the tree search during the resolution.
Printing the decisions slows down the search process.

&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: Limits</title>
      <link>https://choco-solver.org/docs/solving/limits/</link>
      <pubDate>Fri, 06 Mar 2020 17:54:10 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/limits/</guid>
      <description>
        
        
        &lt;h2 id=&#34;built-in-search-limits&#34;&gt;Built-in search limits&lt;/h2&gt;
&lt;p&gt;Search can be limited in various ways using the &lt;code&gt;Solver&lt;/code&gt; (from &lt;code&gt;model.getSolver()&lt;/code&gt;).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitTime&lt;/code&gt; stops the search when the given time limit has been reached. This is the most common limit, as many applications have a limited available runtime.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitSolution&lt;/code&gt; stops the search when the given solution limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitNode&lt;/code&gt; stops the search when the given search node limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitFail&lt;/code&gt; stops the search when the given fail limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;limitBacktrack&lt;/code&gt; stops the search when the given backtrack limit has been reached.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    The potential search interruption occurs at the end of a propagation, i.e. it will not interrupt a propagation algorithm, so the overall runtime of the solver might exceed the time limit.

&lt;/div&gt;

&lt;p&gt;For instance, to interrupt search after 10 seconds:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver s = model.getSolver();
s.limitTime(&amp;quot;10s&amp;quot;);
model.getSolver().solve();
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;custom-search-limits&#34;&gt;Custom search limits&lt;/h3&gt;
&lt;p&gt;You can design you own search limit by implementing a &lt;code&gt;Criterion&lt;/code&gt; and using &lt;code&gt;resolver.limitSearch(Criterion c)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver s = model.getSolver();
s.limitSearch(new Criterion() {
    @Override
    public boolean isMet() {
        // todo return true if you want to stop search
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Java 8, this can be shortened using lambda expressions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver s = model.getSolver();
s.limitSearch(() -&amp;gt; { /*todo return true if you want to stop search*/ });
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Large Neighborhood Search</title>
      <link>https://choco-solver.org/docs/solving/lns/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/lns/</guid>
      <description>
        
        
        &lt;p&gt;Local search techniques are very effective to solve hard optimization problems.
Most of them are, by nature, incomplete.
In the context of constraint programming (CP) for optimization problems, one of the most well-known and widely used local search techniques is the Large Neighborhood Search (LNS) algorithm .
The basic idea is to iteratively relax a part of the problem, then to use constraint programming to evaluate and bound the new solution.&lt;/p&gt;
&lt;h2 id=&#34;principle&#34;&gt;Principle&lt;/h2&gt;
&lt;p&gt;LNS is a two-phase algorithm which partially relaxes a given solution and repairs it.
Given a solution as input, the relaxation phase builds a partial solution (or neighborhood) by choosing a set of variables to reset to their initial domain;
The remaining ones are assigned to their value in the solution.
This phase is directly inspired from the classical Local Search techniques.
Even though there are various ways to repair the partial solution, we focus on the technique in which Constraint Programming is used to bound the objective variable and
to assign a value to variables not yet instantiated.
These two phases are repeated until the search stops (optimality proven or limit reached).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;INeighborFactory&lt;/code&gt; provides pre-defined configurations.
Here is the way to declare LNS to solve a problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setLNS(INeighborFactory.random(ivars, new FailCounter(solver, 100));
solver.findOptimalSolution(Model.MINIMIZE, objective);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It declares a &lt;em&gt;random&lt;/em&gt; LNS which, on a solution, computes a partial solution based on &lt;code&gt;ivars&lt;/code&gt;.
If no solution are found within 100 fails (&lt;code&gt;FailCounter(solver, 100)&lt;/code&gt;), a restart is forced.&lt;/p&gt;
&lt;p&gt;The factory provides other built-in neighbors.&lt;/p&gt;
&lt;h2 id=&#34;neighbors&#34;&gt;Neighbors&lt;/h2&gt;
&lt;p&gt;While the implementation of LNS is straightforward, the main difficulty lies in the design of neighborhoods able to move the search further.
Indeed, the balance between diversification (i.e., evaluating unexplored sub-tree) and intensification (i.e., exploring them exhaustively) should be well-distributed.&lt;/p&gt;
&lt;h3 id=&#34;generic-neighbors&#34;&gt;Generic neighbors&lt;/h3&gt;
&lt;p&gt;One drawback of LNS is that the relaxation process is quite often problem dependent.
Some works have been dedicated to the selection of variables to relax through general concept not related to the class of the problem treated [5,24].
However, in conjunction with CP, only one generic approach, namely Propagation-Guided LNS [24], has been shown to be very competitive with dedicated ones on a variation of the Car Sequencing Problem.
Nevertheless, such generic approaches have been evaluated on a single class of problem and need to be thoroughly parametrized at the instance level, which may be a tedious task to do.
It must, in a way, automatically detect the problem structure in order to be efficient.
The details of the methods to be implemented are given in the &lt;a href=&#34;https://choco-solver.org/docs/advanced-usages/strategies/#large-neighborhood-search-lns&#34;&gt;Advanced section&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;combining-neighborhoods&#34;&gt;Combining neighborhoods&lt;/h3&gt;
&lt;p&gt;There are two ways to combine neighbors.&lt;/p&gt;
&lt;h4 id=&#34;sequential&#34;&gt;Sequential&lt;/h4&gt;
&lt;p&gt;Declare an instance of &lt;code&gt;SequenceNeighborhood(n1, n2, ..., nm)&lt;/code&gt;.
Each neighbor &lt;code&gt;ni&lt;/code&gt; is applied in a sequence until one of them leads to a solution.
At step &lt;code&gt;k&lt;/code&gt;, the $(k \mod m)^{th}$ neighbor is selected.
The sequence stops if at least one of the neighbor is complete.&lt;/p&gt;
&lt;h4 id=&#34;adaptive&#34;&gt;Adaptive&lt;/h4&gt;
&lt;p&gt;Declare an instance of &lt;code&gt;AdaptiveNeighborhood(1L, n1, n2, ..., nm)&lt;/code&gt;.
At the beginning a weight $w_i = 1$ is assigned to each neighbor &lt;code&gt;ni&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If a neighbor leads to solution, its weight $w_i$ is increased by 1.
Any time a partial solution has to be computed, a value &lt;code&gt;W&lt;/code&gt; between 1 and $w_1+w_2+&amp;hellip;+w_n$ is randomly picked (&lt;code&gt;1L&lt;/code&gt; is the seed).&lt;/p&gt;
&lt;p&gt;Then the weight of each neighbor is subtracted from &lt;code&gt;W&lt;/code&gt;, as soon as &lt;code&gt;W&lt;/code&gt;$\leq 0$, the corresponding neighbor is selected.&lt;/p&gt;
&lt;p&gt;For instance, let’s consider three neighbors &lt;code&gt;n1&lt;/code&gt;, &lt;code&gt;n2&lt;/code&gt; and &lt;code&gt;n3&lt;/code&gt;, their respective weights $w1=2, w2=4, w3=1$. 3 is randomly assigned to &lt;code&gt;W&lt;/code&gt;.
Then, the weight of &lt;code&gt;n1&lt;/code&gt; is subtracted, &lt;code&gt;W&lt;/code&gt;$- 2 = 1$ ; the weight of &lt;code&gt;n2&lt;/code&gt; is subtracted, &lt;code&gt;W&lt;/code&gt;$- 3 = -3$, &lt;code&gt;W&lt;/code&gt; is less than 0 and n2 is selected.&lt;/p&gt;
&lt;h2 id=&#34;restarts&#34;&gt;Restarts&lt;/h2&gt;
&lt;p&gt;A generic and common way to reinforce diversification of LNS is to introduce &lt;a href=&#34;https://choco-solver.org/docs/solving/restarts/&#34;&gt;restarts&lt;/a&gt; during the search process.
This technique has proven to be very flexible and to be easily integrated within standard backtracking procedures .&lt;/p&gt;
&lt;h2 id=&#34;walking&#34;&gt;Walking&lt;/h2&gt;
&lt;p&gt;A complementary technique that appear to be efficient in practice is named &lt;code&gt;Walking&lt;/code&gt; and consists in accepting equivalent intermediate solutions in a search iteration instead of requiring a strictly better one.&lt;/p&gt;
&lt;p&gt;This can be achieved by defining an &lt;code&gt;ObjectiveManager&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setObjectiveManager(new ObjectiveManager(objective, ResolutionPolicy.MAXIMIZE, false));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where the last parameter, named &lt;code&gt;strict&lt;/code&gt; must be set to false to accept equivalent intermediate solutions.&lt;/p&gt;
&lt;p&gt;Other optimization policies may be encoded by using either search monitors or a custom &lt;code&gt;ObjectiveManager&lt;/code&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Restarts</title>
      <link>https://choco-solver.org/docs/solving/restarts/</link>
      <pubDate>Tue, 07 Jan 2020 16:06:55 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/restarts/</guid>
      <description>
        
        
        &lt;p&gt;Restart means stopping the current tree search, then starting a new tree search from the root node.
Restarting makes sense only when coupled with randomized dynamic branching strategies ensuring that the same enumeration tree is not constructed twice.
The branching strategies based on the past experience of the search, such as adaptive search strategies, are more accurate in combination with a restart approach.&lt;/p&gt;
&lt;p&gt;Unless the number of allowed restarts is limited, a tree search with restarts is not complete anymore. It is a good strategy, though, when optimizing an NP-hard problem in a limited time.&lt;/p&gt;
&lt;p&gt;Some adaptive search strategies resolutions are improved by sometimes restarting the search exploration from the root node.
Thus, the statistics computed on the bottom of the tree search can be applied on the top of it.&lt;/p&gt;
&lt;p&gt;Several restart strategies are available in &lt;code&gt;Solver&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;on-solutions&#34;&gt;On solutions&lt;/h3&gt;
&lt;p&gt;It may be relevant to restart after each solution.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Restarts after after each new solution.
solver.setRestartOnSolutions()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;geometrical&#34;&gt;Geometrical&lt;/h3&gt;
&lt;p&gt;Geometrical restarts perform a search with restarts controlled by the resolution event  &lt;code&gt;counter&lt;/code&gt; which counts events occurring during the search.
Parameter &lt;code&gt;base&lt;/code&gt; indicates the maximal number of events allowed in the first search tree.
Once this limit is reached, a restart occurs and the search continues until &lt;code&gt;base&lt;/code&gt;$\times$&lt;code&gt; grow&lt;/code&gt; events are done, and so on.
After each restart, the limit number of events is increased by the geometric factor &lt;code&gt;grow&lt;/code&gt;.
&lt;code&gt;limit&lt;/code&gt; states the maximum number of restarts.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setGeometricalRestart(int base, double grow, ICounter counter, int limit)
&lt;/code&gt;&lt;/pre&gt;


&lt;div class=&#34;alert alert-primary&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Info&lt;/h4&gt;

    Some counters may required an argument on constructor that defines the limit to not overpass.
Such an argument is ignored by a restart strategy which overrides that value with its own computed one.

&lt;/div&gt;

&lt;h3 id=&#34;luby&#34;&gt;Luby&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.47.5558&#34;&gt;Luby&lt;/a&gt; ’s restart policy is an alternative to the geometric restart policy.
It performs a search with restarts controlled by the number of resolution events  counted by &lt;code&gt;counter&lt;/code&gt;.
The maximum number of events allowed at a given restart iteration is given by base multiplied by the Las Vegas coefficient at this iteration.
The sequence of these coefficients is defined recursively on its prefix subsequences:
starting from the first prefix $1$, the $(k+1)^{th}$ prefix is the $k^{th}$ prefix repeated &lt;code&gt;grow&lt;/code&gt; times and
immediately followed by coefficient &lt;code&gt;grow&lt;/code&gt;$^k$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the first coefficients for &lt;code&gt;grow&lt;/code&gt; = 2 :
$$ [1,1,2,1,1,2,4,1,1,2,1,1,2,4,8,1,\cdots]$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the first coefficients for &lt;code&gt;grow&lt;/code&gt; =3 :
$$ [1, 1, 1, 3, 1, 1, 1, 3, 1, 1, 1, 3, 9,\cdots] $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setLubyRestart(int base, int grow, ICounter counter, int limit)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can design your own restart strategies using:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setRestarts( LongCriterion restartCriterion,
                    IRestartStrategy restartStrategy,
                    int restartsLimit);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;recording-no-goods-on-restart&#34;&gt;Recording no-goods on restart&lt;/h3&gt;
&lt;p&gt;When a restart occurs, one may want to prevent the search space explored before restarting to be discovered again in the future. This is achieved by recording &lt;em&gt;no-goods&lt;/em&gt; on restart.&lt;/p&gt;
&lt;p&gt;By calling:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;solver.setNoGoodRecordingFromRestarts();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;anytime a restart occurs, a &lt;em&gt;no-good&lt;/em&gt; is extracted from the decision path in order to prevent the same scanning the same sub-tree in the futur.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Multi-thread resolution</title>
      <link>https://choco-solver.org/docs/solving/portfolio/</link>
      <pubDate>Fri, 06 Mar 2020 15:39:27 +0100</pubDate>
      
      <guid>https://choco-solver.org/docs/solving/portfolio/</guid>
      <description>
        
        
        &lt;p&gt;Choco 4 provides a simple way to use several threads to treat a problem. The main idea of that driver is to solve the &lt;em&gt;same&lt;/em&gt; model with different search strategies and to share few information to make these threads help each others.&lt;/p&gt;
&lt;p&gt;To use a portfolio of solvers in parallel, use &lt;code&gt;ParallelPortfolio&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ParallelPortfolio portfolio = new ParallelPortfolio();
int nbModels = 5;
for(int s=0;s&amp;lt;nbModels;s++){
    portfolio.addModel(makeModel());
}
portfolio.solve();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, &lt;code&gt;makeModel()&lt;/code&gt; is a method you have to implement to create a &lt;code&gt;Model&lt;/code&gt; of the problem.
Here all models are the same and the portfolio will change the search heuristics of all models but the first one.
This means that the first thread will run according to your settings whereas the others will have a different configuration.&lt;/p&gt;
&lt;h3 id=&#34;auto-configuration&#34;&gt;Auto-configuration&lt;/h3&gt;
&lt;p&gt;In order to specify yourself the configuration of each thread, you need to create the portfolio by setting the optional
boolean argument &lt;code&gt;searchAutoConf&lt;/code&gt; to false as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ParallelPortfolio portfolio = new ParallelPortfolio(false);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this second example, the parameter &lt;code&gt;s&lt;/code&gt; enables you to change the search strategy within the &lt;code&gt;makeModel&lt;/code&gt; method (e.g. using a &lt;code&gt;switch(s)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;When dealing with multithreading resolution, very few data is shared between threads:
everytime a solution has been found its value is shared among solvers. Moreover,
when a solver ends, it communicates an interruption instruction to the others.
This enables to explore the search space in various way, using different model settings such as search strategies
(this should be done in the dedicated method which builds the model, though).&lt;/p&gt;
&lt;h3 id=&#34;sharing-no-goods&#34;&gt;Sharing no-goods&lt;/h3&gt;
&lt;p&gt;Some of the default search strategies are based on a restart policy.
In such case, one can allow no-goods when those threads restart.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;portfolio.stealNogoodsOnRestarts();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Doing so, anytime a thread restarts, it records not only no-goods based on the search space it has explored since last restart, but also ones of other threads (restricted to those equipepd with a restart policy).&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
