<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Choco-solver â€“ First Example</title>
    <link>/tutorials/first-example/</link>
    <description>Recent content in First Example on Choco-solver</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 31 Jan 2020 11:22:32 +0100</lastBuildDate>
    
	  <atom:link href="/tutorials/first-example/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Tutorials: Designing a propagator</title>
      <link>/tutorials/first-example/first-example/</link>
      <pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorials/first-example/first-example/</guid>
      <description>
        
        
        &lt;p&gt;First of all, let&amp;rsquo;s consider the eight queen puzzle, frequently used to
introduce constraint programming.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Eight_queens_puzzle&#34;&gt;Wikipedia&lt;/a&gt; told us
that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The eight queens puzzle is the problem of placing eight chess queens
on an 8x8 chessboard so that no two queens threaten each other. Thus,
a solution requires that no two queens share the same row, column, or
diagonal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The problem can be generalized to the &lt;em&gt;n&lt;/em&gt;-queens problem (placing &lt;em&gt;n&lt;/em&gt;
queens on a nxn chessboard).&lt;/p&gt;
&lt;p&gt;There are many ways to model this problem with Choco, we will start with
a basic one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt; :linenos:
 :emphasize-lines: 2,3,5,9-11,14}
int n = 8;
Model model = new Model(n + &amp;quot;-queens problem&amp;quot;);
IntVar[] vars = new IntVar[n];
for(int q = 0; q &amp;lt; n; q++){
    vars[q] = model.intVar(&amp;quot;Q_&amp;quot;+q, 1, n);
}
for(int i  = 0; i &amp;lt; n-1; i++){
    for(int j = i + 1; j &amp;lt; n; j++){
        model.arithm(vars[i], &amp;quot;!=&amp;quot;,vars[j]).post();
        model.arithm(vars[i], &amp;quot;!=&amp;quot;, vars[j], &amp;quot;-&amp;quot;, j - i).post();
        model.arithm(vars[i], &amp;quot;!=&amp;quot;, vars[j], &amp;quot;+&amp;quot;, j - i).post();
    }
}
Solution solution = model.getSolver().findSolution();
if(solution != null){
    System.out.println(solution.toString());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you copy/paste the this code and execute it, it prints the value that
each variable takes in the solution on the console :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Solution: Q_0=7, Q_1=4, Q_2=2, Q_3=5, Q_4=8, Q_5=1, Q_6=3, Q_7=6,
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let&amp;rsquo;s discuss the code.&lt;/p&gt;
&lt;h3 id=&#34;the-model&#34;&gt;The model&lt;/h3&gt;
&lt;p&gt;On line 2, a &lt;em&gt;model&lt;/em&gt; is declared. It is the key component of the library
and needed to describe any problem.&lt;/p&gt;
&lt;h3 id=&#34;the-variables&#34;&gt;The variables&lt;/h3&gt;
&lt;p&gt;A queen position is defined by its coordinates on the chessboard.
Naturally, we don&amp;rsquo;t know yet where to put queens on the chessboard, but
we can give indications. To do so, we need to declare &lt;em&gt;variables&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A variable is an &lt;em&gt;unknown&lt;/em&gt; which has to be assigned to value in a
solution. The values a variable can take is defined by its domain.&lt;/p&gt;
&lt;p&gt;Here, in a solution, there will be exactly one queen per row (and per
column). So, a modelling trick is to fix the row a queen can go to and
only question on their column. Thus, there will be &lt;em&gt;n&lt;/em&gt; queens (one per
row), each of them to be assigned to one column, among $[1,n]$.&lt;/p&gt;
&lt;p&gt;Lines 3 and 5 managed to create variables and their domain.&lt;/p&gt;
&lt;h3 id=&#34;the-constraints&#34;&gt;The constraints&lt;/h3&gt;
&lt;p&gt;The queens&amp;rsquo; position must follow some rules. We already encoded that
there can only be one queen per row. Now, we have to ensure that, on any
solution, no two queens share the same column and diagonal.&lt;/p&gt;
&lt;p&gt;First, the columns conditions: if the queen &lt;em&gt;i&lt;/em&gt; is on column &lt;em&gt;k&lt;/em&gt;, then
any other queens cannot take the value &lt;em&gt;k&lt;/em&gt;. So, for each pair of queens,
the two related variables cannot be assigned to the same value. This is
expressed by the &lt;em&gt;constraint&lt;/em&gt; on line 9. To activate the constraint, it
has to be &lt;em&gt;posted&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Second, the diagonals: we have to consider the two orthogonal diagonals.
If the queen &lt;em&gt;i&lt;/em&gt; is on column &lt;em&gt;k&lt;/em&gt;, then, the queen &lt;em&gt;i+1&lt;/em&gt; cannot be
assigned to &lt;em&gt;k+1&lt;/em&gt;. More generally, the queen &lt;em&gt;i+m&lt;/em&gt; cannot be assigned to
&lt;em&gt;k+m&lt;/em&gt;. The same goes with the other diagonal. This is declared on line
10 and 11.&lt;/p&gt;
&lt;h3 id=&#34;solving-the-problem&#34;&gt;Solving the problem&lt;/h3&gt;
&lt;p&gt;Once the problem has been described into a model using variables and
constraints, its satisfaction can be evaluated, by trying to &lt;em&gt;solve&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;This is achieved on line 14 by calling the getSolver().findSolution()
method from the model. If a solution exists, it is printed on the
console&lt;/p&gt;
&lt;h2 id=&#34;what-to-do-next-&#34;&gt;What to do next ?&lt;/h2&gt;
&lt;p&gt;We are going to use and extend this small problem in the future. But
before, we will have a look at the different objects we can manipulate.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Tutorials: Main objects</title>
      <link>/tutorials/first-example/objects/</link>
      <pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorials/first-example/objects/</guid>
      <description>
        
        
        &lt;p&gt;The content of this section is extracted from the Javadoc and the
&lt;a href=&#34;/documentation&#34;&gt;Documentation&lt;/a&gt;. Here, we &lt;strong&gt;briefly&lt;/strong&gt; described the main aspects of
the most commonly used objects. This does not aim at being complete: it
covers the basic information.&lt;/p&gt;
&lt;h2 id=&#34;the-model&#34;&gt;The Model&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;Model model = new Model(&amp;quot;My model&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As said before, the Model is a key component of the library. It has to
be the first instruction declared, since it provides entry point methods
that help modelling a problem.&lt;/p&gt;
&lt;p&gt;A good habit is to declare a model with a name, otherwise a random one
will be assigned by default.&lt;/p&gt;
&lt;p&gt;We designed the model in such a way that you can reach almost everything
needed to describe a problem from it.&lt;/p&gt;
&lt;p&gt;For example, it stores its variables and constraints. Variables and
constraints of a model can be retrieved thanks to API :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;model.retrieveIntVars(true); // extract IntVars, including BoolVars
model.getCstrs(); // extract posted constraints
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We strongly encourage you to attach the Javadoc (provides either on
the website or on Maven Central Repository) to the library in your
IDE.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;the-variables&#34;&gt;The Variables&lt;/h2&gt;
&lt;p&gt;A variable is an &lt;em&gt;unknown&lt;/em&gt;, mathematically speaking. In a solution of a
given problem (considering that at least one exists), each variable is
assigned to a &lt;em&gt;value&lt;/em&gt; selected within its domain. The notion of &lt;em&gt;value&lt;/em&gt;
differs from one type of variable to the other.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A variable can be declared in only one model at a time. Indeed, a
reference to the declaring model is maintained in it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;integer-variable&#34;&gt;Integer variable&lt;/h3&gt;
&lt;p&gt;An integer variable, IntVar, should be assigned to an integer. There are
many ways to declare an IntVar&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;// A variable with a unique value in its domain, in other words, a constant
IntVar two = model.intVar(&amp;quot;TWO&amp;quot;, 2);
// Any value in [1..4] can be assigned to this variable
IntVar x = model.intVar(&amp;quot;X&amp;quot;, 1, 4);
// Only the values 1, 3 and 4 can be assigned to this variable
IntVar y = model.intVar(&amp;quot;X&amp;quot;, new int[]{1, 3, 4});
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;caution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Declaring a variable with an &lt;em&gt;infinite&lt;/em&gt; domain, like :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;model.intVar(&amp;quot;X&amp;quot;, Integer.MIN_VALUE, Integer.MAX_VALUE)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;is clearly a bad idea.&lt;/p&gt;
&lt;p&gt;Too large domains may lead to underflow or overflow issues and most of
the time, even if Choco will finally compute the right bounds by
itself, you certainly want to save space and time by directly
declaring relevant bounds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The domain of an integer variable in Choco can either be &lt;em&gt;bounded&lt;/em&gt; or
&lt;em&gt;enumerated&lt;/em&gt;. In a bounded domain, only current bounds are stored in
memory. This saves memory (only two integers are needed) but it
restricts its usage: there is no possibility to make holes in it.&lt;/p&gt;
&lt;p&gt;On the contrary, with an enumerated domain, all possible values are
explicitly stored in memory. This consumes more memory (one integer and
a bitset &amp;ndash; many longs &amp;ndash; are needed) but it allows making holes in it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;Modelling&lt;/strong&gt;: Bounded or Enumerated?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The memory consumption should not be the only criterion to consider
when one needs to choose between one representation and the other.
Indeed, the &lt;em&gt;filtering&lt;/em&gt; strength of the model, through constraints,
has to be considered too. For instance, some constraints can only
deduce bound updates, in that case bounded domains fit the need. Other
constraints can make holes in variables&amp;rsquo; domain, in that case
enumerated domains are relevant.&lt;/p&gt;
&lt;p&gt;If you don&amp;rsquo;t know what to do, the following scenario can be applied:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;domain&amp;rsquo;s cardinality greater than 262144 should be bounded&lt;/li&gt;
&lt;li&gt;domain&amp;rsquo;s cardinality smaller than 32768 can be enumerated
without loss of efficiency&lt;/li&gt;
&lt;li&gt;in any case, empirical evaluation is a good habit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;boolean-variable&#34;&gt;Boolean variable&lt;/h3&gt;
&lt;p&gt;An boolean variable, BoolVar, should be assigned to a boolean. A BoolVar
is a specific IntVar with a domain restricted to $[0,1]$, 0 stands for
false, 1 for true. Thus a BoolVar can be declared in any integer
constraint (&lt;em&gt;e.g.&lt;/em&gt;, a sum) and boolean constraints (&lt;em&gt;e.g.&lt;/em&gt;, in clauses
store).&lt;/p&gt;
&lt;p&gt;Here is the common way to declare a BoolVar&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;// A [0,1]-variable
BoolVar b = model.boolVar(&amp;quot;b&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;set-variable&#34;&gt;Set variable&lt;/h3&gt;
&lt;p&gt;A set variable, SetVar, should be assigned to a set of integers
(possibly empty or singleton). Its domain is defined by a set of
intervals [LB,UB] where LB denotes the integers that figure in all
solutions and UB the integers that potentially figure in a solution.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;// SetVar representing a subset of {1,2,3,5,12}
SetVar y = model.setVar(&amp;quot;y&amp;quot;, new int[]{}, new int[]{1,2,3,5,12});
// possible values: {}, {2}, {1,3,5} ...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;real-variable&#34;&gt;Real variable&lt;/h3&gt;
&lt;p&gt;A real variable, RealVar, should be assigned an interval of doubles. Its
domain is defined by its bounds and a &lt;em&gt;precision&lt;/em&gt;. The precision
parameter helps considering a real variable as instantiated: when the
distance between the two bounds is less than or equal to the precision.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;// A [0.2d, 3.4d]-variable, with a precision of 0.001d
RealVar x = model.realVar(&amp;quot;x&amp;quot;, 0.2d, 3.4d, 0.001d);
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Using RealVar requires to install &lt;a href=&#34;http://www.ibx-lib.org&#34;&gt;Ibex&lt;/a&gt;
before. Indeed, Choco relies on Ibex to deal with continuous
constraints.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;the-constraints&#34;&gt;The Constraints&lt;/h2&gt;
&lt;p&gt;A constraint is a relation between one or more variables of a model. It
defines conditions over these variables that must be respected in a
solution. A constraint has a semantic (&lt;em&gt;e.g.&lt;/em&gt;, &amp;ldquo;greater than&amp;rdquo; or &amp;ldquo;all
different&amp;rdquo;) and is equipped with &lt;em&gt;filtering algorithms&lt;/em&gt; that ensure
conditions induced by the semantic hold.&lt;/p&gt;
&lt;p&gt;A filtering algorithm, or &lt;em&gt;propagator&lt;/em&gt;, removes from variables&amp;rsquo; domain
values that cannot appear in any solution. A propagator has a &lt;em&gt;filtering
strength&lt;/em&gt; and a time complexity to achieve it. The filtering strength,
or &lt;em&gt;level of consistency&lt;/em&gt;, determines how accurate a propagator is when
values to be removed are detected.&lt;/p&gt;
&lt;h3 id=&#34;posting-a-constraint&#34;&gt;Posting a constraint&lt;/h3&gt;
&lt;p&gt;For a constraint to be integrated in a model, a call to post() is
required :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;// x and y must be different in any solution
model.arithm(x, &amp;quot;!=&amp;quot;, y).post();
// or, in a more verbose way
model.post(model.arithm(x, &amp;quot;&amp;lt;&amp;quot;, z));
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A constraint can be posted in only one model at a time. Indeed, a
reference to the declaring model is maintained in it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Once posted, a constraint is known from a model and will be integrated
in the filtering loop.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Posting a constraint does not remove any value from its variables&amp;rsquo;
domain. Indeed, Choco runs the &lt;em&gt;initial propagation&lt;/em&gt; only when a
resolution is called.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The only reason why a constraint is not posted a model is to &lt;em&gt;reify&lt;/em&gt; it.&lt;/p&gt;
&lt;h3 id=&#34;reifying-a-constraint&#34;&gt;Reifying a constraint&lt;/h3&gt;
&lt;p&gt;Alternatively, a constraint can be reified with a BoolVar :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;// the constraint is reified with `b`
BoolVar r1 = model.arithm(x, &amp;quot;!=&amp;quot;, y).reify();
// equivalent to:
BoolVar r2 = model.boolVar(&amp;quot;r2&amp;quot;);
model.arithm(x, &amp;quot;&amp;lt;&amp;quot;, z).reifyWith(r2);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The BoolVar that reifies a constraint represents whether or not a
constraint is satisfied. If the constraint is satisfied, the boolean
variable is set to true, false otherwise. If the boolean variable is set
to true the constraint should be satisfied, unsatisfied otherwise.&lt;/p&gt;
&lt;p&gt;Reifying constraints is helpful to express conditions like:
(x = y) xor (x &amp;gt; 15) :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;BoolVar c1 = model.arithm(x, &amp;quot;=&amp;quot;, y).reify();
BoolVar c2 = model.arithm(x, &amp;quot;&amp;gt;&amp;quot;, 15).reify();
model.arithm(c1, &amp;quot;+&amp;quot;, c2, &amp;quot;=&amp;quot;, 1).post();
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;warning&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A reified constraint &lt;strong&gt;should not&lt;/strong&gt; be posted. Indeed, posting it will
declare it as a &lt;em&gt;hard&lt;/em&gt; constraint, to be satisfied, reifying it will
declare it as a &lt;em&gt;soft&lt;/em&gt; constraint, that can be unsatisfied. Both state
cannot co-exist simultaneously: hard state dominates soft one.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;caution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A constraint that is neither posted or reified &lt;strong&gt;is not considered at
all&lt;/strong&gt; in the resolution. Make sure all constraints are either posted
or reified.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There are more than 80 constraints in Choco, and anyone can create its
own constraint easily. Native constraints are provided by the model, as
seen before. A look at the Javadoc gives a big picture of the ones
available. In this tutorial, we will have a look at the most commonly
used ones.&lt;/p&gt;
&lt;h2 id=&#34;the-solver&#34;&gt;The Solver&lt;/h2&gt;
&lt;p&gt;The Model serves at describing the problem with variables and
constraints. The resolution is managed by the Solver.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;Model model = new Model(&amp;quot;My problem&amp;quot;);
// variables declaration
// constraints declaration
Solver solver = model.getSolver();
Solution solution = solver.findSolution();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Having access to the Solver is needed to tune the resolution and launch
it. It provides methods to configure &lt;em&gt;search strategies&lt;/em&gt;, to define
resolution goals (&lt;em&gt;i.e.&lt;/em&gt;, finding one solution, all solutions or optimal
solutions) and getting resolution statistics.&lt;/p&gt;
&lt;p&gt;Instead of listing all resolution features, we will see some of them in
the following.&lt;/p&gt;
&lt;h2 id=&#34;modelling-and-solving&#34;&gt;Modelling and Solving&lt;/h2&gt;
&lt;p&gt;Carefully selecting variables and constraints to describe a problem in a
model is a tough task to do. Indeed, some knowledge of the available
constraints (or their reformulations), their filtering strength and
complexity, is needed to take advantage of Constraint Programming. This
has to be both taught and experimented. Same goes with the resolution
tuning. Using Choco has a black-box solver results in good performance
on average. But, injecting problem expertise in the search process is a
key component of success. Choco offers a large range of features to let
you good chances to master your problem.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Tutorials: Playing around with 8-queens puzzle</title>
      <link>/tutorials/first-example/follow-up/</link>
      <pubDate>Fri, 31 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>/tutorials/first-example/follow-up/</guid>
      <description>
        
        
        &lt;p&gt;We will now see and comment some modifications of the code presented
previously :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt; :linenos:}
int n = 8;
Model model = new Model(n + &amp;quot;-queens problem&amp;quot;);
IntVar[] vars = new IntVar[n];
for(int q = 0; q &amp;lt; n; q++){
    vars[q] = model.intVar(&amp;quot;Q_&amp;quot;+q, 1, n);
}
for(int i  = 0; i &amp;lt; n-1; i++){
    for(int j = i + 1; j &amp;lt; n; j++){
        model.arithm(vars[i], &amp;quot;!=&amp;quot;,vars[j]).post();
        model.arithm(vars[i], &amp;quot;!=&amp;quot;, vars[j], &amp;quot;-&amp;quot;, j - i).post();
        model.arithm(vars[i], &amp;quot;!=&amp;quot;, vars[j], &amp;quot;+&amp;quot;, j - i).post();
    }
}
Solution solution = model.getSolver().findSolution();
if(solution != null){
    System.out.println(solution.toString());
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;variables&#34;&gt;Variables&lt;/h2&gt;
&lt;p&gt;First, lines 3-6 can be compacted into:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;IntVar[] vars = model.intVarArray(&amp;quot;Q&amp;quot;, n, 1, n, false);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Doing so, an n-array of variables with [1,n]-domain is created. Each
variable name is &amp;ldquo;Q[i]&amp;rdquo; where &lt;em&gt;i&lt;/em&gt; is its position in the array, starting
from 0. The last parameter, set to false, indicates that the domains
must be enumerated (not bounded).&lt;/p&gt;
&lt;h2 id=&#34;constraints&#34;&gt;Constraints&lt;/h2&gt;
&lt;p&gt;Second, lines 9 to 11 can be replaced by:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;vars[i].ne(vars[j]).post();
vars[i].ne(vars[j].sub(j - i)).post();
vars[i].ne(vars[j].add(j - i)).post();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;where ne stands for not equal. Theses instructions express the same
constraints, or more complex expressions, in a convenient way. Here the
expression is posted as a decomposition: the AST is analyzed and
additional variables and constraints are added on the fly.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;note&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Calling e.post() on an expression e is a syntactic sugar for
e.decompose().post().&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Alternatively, one can decide to generate the possible combinations from
the expression and post &lt;em&gt;table&lt;/em&gt; constraints &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. To do so, the
expression should be first turned into extension constraint then be
posted&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;vars[i].ne(vars[j]).extension().post();
vars[i].ne(vars[j].sub(j - i)).extension().post();
vars[i].ne(vars[j].add(j - i)).extension().post();
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;global-constraints&#34;&gt;Global constraints&lt;/h2&gt;
&lt;p&gt;Here we posted three groups of 28 constraints. The first group expresses
that two queens cannot be on the same column by posting a &lt;em&gt;clique&lt;/em&gt; of
inequality constraints. The second and third groups express the same
conditions for each diagonal.&lt;/p&gt;
&lt;p&gt;In other words, the variables of each groups must be &lt;em&gt;all different&lt;/em&gt;.
Luckily, there exists a &lt;em&gt;global constraint&lt;/em&gt; that captures that
conditions:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Global constraints specify patterns that occur in many problems and
exploit efficient and effective constraint propagation algorithms for
pruning the search space.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;(&amp;quot;&lt;em&gt;The Complexity of Global Constraints&lt;/em&gt;&amp;quot;, C.BessiÃ¨re, E.Hebrard,
B.Hnich and T.Walsh, AAAI 2004.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We can reformulate the set of constraints to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt; :linenos:}
IntVar[] diag1 = new IntVar[n];
IntVar[] diag2 = new IntVar[n];
for(int i = 0 ; i &amp;lt; n; i++){
    diag1[i] = vars[i].sub(i).intVar();
    diag2[i] = vars[i].add(i).intVar();
}
model.post(
    model.allDifferent(vars),
    model.allDifferent(diag1),
    model.allDifferent(diag2)
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or with Java8 lambdas:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt; :linenos:}
IntVar[] diag1 = IntStream.range(0, n)
                          .mapToObj(i -&amp;gt; vars[i].sub(i).intVar())
                          .toArray(IntVar[]::new);
IntVar[] diag2 = IntStream.range(0, n)
                           .mapToObj(i -&amp;gt; vars[i].add(i).intVar())
                           .toArray(IntVar[]::new);
model.post(
    model.allDifferent(vars),
    model.allDifferent(diag1),
    model.allDifferent(diag2)
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The constraint on line 8 simply states that all variables from vars must
be different. The constraint on line 9 (or 10) states that all variables
from a diagonal must be different. The variables of a diagonal are given
by
IntStream.range(0, n).mapToObj(i -&amp;gt; vars[i].add(i).intVar()).toArray(IntVar[]::new)
(lines 4-6) which construct an array of IntVar from the mapping function
-&amp;gt; vars[i].add(i).intVar(). This function maps each index &lt;em&gt;i&lt;/em&gt; in the
[0,n] range to an integer variable equals to vars[i].add(i). The call to
the intVar() method effectively turns the arithmetic expression into an
integer variable. This extraction may introduce additional variables and
constraints automatically.&lt;/p&gt;
&lt;h2 id=&#34;solver&#34;&gt;Solver&lt;/h2&gt;
&lt;p&gt;To compare the first model and the modified one, we need to get features
and measures. A call to solver.showStatistics(); will output commonly
used indicators to the console, such as the number of variables,
constraints, solutions found, open nodes, etc.&lt;/p&gt;
&lt;p&gt;We can either let the solver explore the search space by itself or
define a search strategy, like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;solver.setSearch(Search.domOverWDegSearch(vars));
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;updated-code&#34;&gt;Updated code&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt; :linenos:}
int n = 8;
Model model = new Model(n + &amp;quot;-queens problem&amp;quot;);
IntVar[] vars = model.intVarArray(&amp;quot;Q&amp;quot;, n, 1, n, false);
IntVar[] diag1 = IntStream.range(0, n).mapToObj(i -&amp;gt; vars[i].sub(i).intVar()).toArray(IntVar[]::new);
IntVar[] diag2 = IntStream.range(0, n).mapToObj(i -&amp;gt; vars[i].add(i).intVar()).toArray(IntVar[]::new);
model.post(
    model.allDifferent(vars),
    model.allDifferent(diag1),
    model.allDifferent(diag2)
);
Solver solver = model.getSolver();
solver.showStatistics();
solver.setSearch(Search.domOverWDegSearch(vars));
Solution solution = solver.findSolution();
if (solution != null) {
    System.out.println(solution.toString());
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Running the following code outputs something like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{.sourceCode&#34; data-lang=&#34;{.sourceCode&#34;&gt;** Choco 4.0.0 (2016-05) : Constraint Programming Solver, Copyleft (c) 2010-2016
- Model[8-queens problem] features:
    Variables : 32
    Constraints : 19
    Default search strategy : no
    Completed search strategy : no
1 solution found.
    Model[8-queens problem]
    Solutions: 1
    Building time : 0,000s
    Resolution time : 0,012s
    Nodes: 6 (491,9 n/s)
    Backtracks: 0
    Fails: 0
    Restarts: 0
    Variables: 32
    Constraints: 19
Solution: Q[0]=7, Q[1]=4, Q[2]=2, Q[3]=8, Q[4]=6, Q[5]=1, Q[6]=3, Q[7]=5,
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Basically, the trace informs that:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;there are 32 variables: the eight queens, and the additional ones
induced by expressions extraction,&lt;/li&gt;
&lt;li&gt;there are 19 constraints: three allDifferent constraints, and the
additional ones induced by expressions extraction,&lt;/li&gt;
&lt;li&gt;one solution has been found,&lt;/li&gt;
&lt;li&gt;it took 11 ms to find it,&lt;/li&gt;
&lt;li&gt;in the meantime, 6 decisions were made and none of them were
wrong.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;such constraint are defined by a set of allowed/forbidden tuples. &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;

      </description>
    </item>
    
  </channel>
</rss>
