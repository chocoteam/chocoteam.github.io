<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Choco-solver – Other examples</title>
    <link>https://choco-solver.org/tutos/other-examples/</link>
    <description>Recent content in Other examples on Choco-solver</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="https://choco-solver.org/tutos/other-examples/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Tutos: The connector problem</title>
      <link>https://choco-solver.org/tutos/other-examples/the-connector-problem/</link>
      <pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://choco-solver.org/tutos/other-examples/the-connector-problem/</guid>
      <description>
        
        
        &lt;p&gt;Description from &lt;em&gt;Bondy, J. and Murty, U. (1976) Graph Theory with Applications. MacMillan, London&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A railway network connecting a number of towns is to be set up. Given the cost $c_{ij}$ of constructing a direct link between towns $v_i$ and $v_j$, design such a network to mininlise the total cost of construction. This is known as the &lt;strong&gt;connector problem&lt;/strong&gt;.
By regarding each town as a vertex in a weighted graph with weights $w(v_ivj) = c_{ij}$, it is clear that this problem is just that of finding, in a weighted graph $G$, a &lt;strong&gt;connected spanning subgraph of minimum weight&lt;/strong&gt;. Moreover,
since the weights represent costs, they are certainly non-negative, and we may therefore assume that such a minimum-weight spanning subgraph is a &lt;strong&gt;spanning tree&lt;/strong&gt; $T$ of $G$. A minimum-weight spanning tree of a weighted graph will be called an &lt;em&gt;optimal tree&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Definition (Minimum Spanning Tree)&lt;/strong&gt;:
&lt;em&gt;A minimum weight spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As an example, we can consider the problem of finding airline network where the objective is to reach all given towns and the cost is relative to the distance between them.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://choco-solver.org/images/tutos/Connector_pb.png&#34; alt=&#34;Connector problem&#34; width=&#34;400&#34;/&gt; &lt;img src=&#34;https://choco-solver.org/images/tutos/Connector_sol.png&#34; alt=&#34;Connector solution&#34; width=&#34;400&#34;/&gt;&lt;/p&gt;
&lt;p&gt;On the left side, the initial network. On the right side, a solution to this problem, with a cost of 12154.&lt;/p&gt;
&lt;p&gt;Now, let&amp;rsquo;s load the data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Load data
String[] cities = new String[]{
  &amp;quot;London&amp;quot;, &amp;quot;Mexico City&amp;quot;, &amp;quot;New York&amp;quot;, &amp;quot;Paris&amp;quot;, &amp;quot;Peking&amp;quot;, &amp;quot;Tokyo&amp;quot;
};

int[][] distances = 
{
  {0, 5558, 3469, 214, 5074, 5959},   // L
  {5558, 0, 2090, 5725, 7753, 7035},  // MC
  {3469, 2090, 0, 3636, 6844, 6757},  // NY
  {214, 5725, 3636, 0, 5120, 6053},   // Pa
  {5074, 7753, 6844, 5120, 0, 1307},  // Pe
  {5959, 7035, 6757, 6053, 1307, 0},  // T
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;imports-and-model&#34;&gt;Imports and model&lt;/h2&gt;
&lt;p&gt;Before going further, create a class and import the following classes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.objects.graphs.UndirectedGraph;
import org.chocosolver.util.objects.setDataStructures.SetType;
import org.chocosolver.solver.variables.UndirectedGraphVar;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then declare a model to work with in a method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Model cop = new Model(&amp;quot;The Connector Problem&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;how-to-build-graphvar&#34;&gt;How to build &lt;code&gt;GraphVar&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;There are 6 nodes in this complete graph.
We can declare a &lt;code&gt;GraphVar&lt;/code&gt; as an undirected graph, that is based on a &lt;em&gt;lower bound&lt;/em&gt; which defines the mandatory elements (vertices and edges) and an &lt;em&gt;upper bound&lt;/em&gt; which defines the optional elements.
Elements can be removed from the upper bound or enforced in the lower bound.
A &lt;code&gt;GraphVar&lt;/code&gt; is considered as instantiated when the lower bound and the upper bound are equal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;UndirectedGraph GLB = new UndirectedGraph(cop, cities.length, SetType.BITSET, true);
UndirectedGraph GUB = new UndirectedGraph(cop, cities.length, SetType.BITSET, true);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The&lt;/strong&gt; last parameter states that all nodes always remain in the graph. The nodes are labeled from 0 to &lt;code&gt;cities.length&lt;/code&gt;-1.
The lower bound of the &lt;code&gt;GraphVar&lt;/code&gt; contains the cities but no edges since none of them are mandatory. The upper bound only contains the cities and the optional edges must now be declared.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;for(int i = 0; i &amp;lt; cities.length; i++){
  for(int j = i+1; j &amp;lt; cities.length; j++){
      GUB.addEdge(i, j);   
  }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is now possible to declare the graph variable &lt;code&gt;G&lt;/code&gt; as follow.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;UndirectedGraphVar graph = cop.graphVar(&amp;quot;G&amp;quot;, GLB, GUB);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see how the current value of the domain of $G$:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void printGLB(){
  System.out.println(&amp;quot;Lower bound of G:&amp;quot;);
  for (int n : graph.getMandatoryNodes()) {
      System.out.printf(&amp;quot;\t%s -&amp;gt; {&amp;quot;, cities[n]);
      for (int v : graph.getMandatoryNeighborsOf(n)){
          System.out.printf(&amp;quot;%s, &amp;quot;, cities[v]);
      }
      System.out.print(&amp;quot;}\n&amp;quot;);
  }
}
 
private void printGUB(){ 
  System.out.println(&amp;quot;Upper bound of G:&amp;quot;);
    for (int n : graph.getPotentialNodes()) {
      System.out.printf(&amp;quot;\t%s -&amp;gt; {&amp;quot;, cities[n]);
      for (int v : graph.getPotentialNeighborsOf(n)){
          System.out.printf(&amp;quot;%s, &amp;quot;, cities[v]);
      }
      System.out.print(&amp;quot;}\n&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling these two methods prints&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Lower bound of G:
  London -&amp;gt; {}
  Mexico City -&amp;gt; {}
  New York -&amp;gt; {}
  Paris -&amp;gt; {}
  Peking -&amp;gt; {}
  Tokyo -&amp;gt; {}
Upper bound of G:
  London -&amp;gt; {Mexico City, New York, Paris, Peking, Tokyo, }
  Mexico City -&amp;gt; {London, New York, Paris, Peking, Tokyo, }
  New York -&amp;gt; {London, Mexico City, Paris, Peking, Tokyo, }
  Paris -&amp;gt; {London, Mexico City, New York, Peking, Tokyo, }
  Peking -&amp;gt; {London, Mexico City, New York, Paris, Tokyo, }
  Tokyo -&amp;gt; {London, Mexico City, New York, Paris, Peking, }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;constraints&#34;&gt;Constraints&lt;/h2&gt;
&lt;p&gt;In order to impose that G is a spanning tree, we post a &lt;strong&gt;degree constrained-minimum spanning tree&lt;/strong&gt; (or &lt;em&gt;dcmst&lt;/em&gt;). Since this constraint offers to constraint the degrees too, it is required to declare variables that define the degree of each node. This is achieved through a channeling constraint between &lt;code&gt;G&lt;/code&gt; and &lt;code&gt;IntVar&lt;/code&gt;s.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntVar[] degrees = cop.intVarArray(&amp;quot;degree&amp;quot;, cities.length, 0, cities.length-1);
cop.degrees(graph, degrees).post();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the constraint is &lt;strong&gt;posted&lt;/strong&gt; to the model. Actually, the other option would be to reify it.&lt;/p&gt;
&lt;p&gt;We also need to get the cost of the spanning tree, in order to minimize it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntVar totalCost = cop.intVar(&amp;quot;cost&amp;quot;, 0, 6*99_999);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now everything is up to post the constraint that ensure that &lt;code&gt;G&lt;/code&gt; is a minimum spanning tree:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cop.dcmst(graph,degrees,totalCost,distances,0).post();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;objective-and-solving&#34;&gt;Objective and solving&lt;/h2&gt;
&lt;p&gt;Since we deal with a Constraint Optimization Problem, an objective variable has to be declared, together with the policy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;cop.setObjective(Model.MINIMIZE, totalCost);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we are ready to run the resolution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver slv = cop.getSolver();
slv.showShortStatistics();
//slv.reset();
while (slv.solve()){
    System.out.printf(&amp;quot;Spanning tree of cost %d\n&amp;quot;, totalCost.getValue());
    printGLB();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which prints :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;...
Model[The Connector Problem], 13 Solutions, MINIMIZE cost = 12154, Resolution time 0.389s, Time to best solution 0.389s, 612 Nodes (1,573.0 n/s), 1184 Backtracks, 0 Backjumps, 583 Fails, 0 Restarts
Spanning tree of cost 12154
Lower bound of G:
  London -&amp;gt; {New York, Paris, Peking, }
  Mexico City -&amp;gt; {New York, }
  New York -&amp;gt; {London, Mexico City, }
  Paris -&amp;gt; {London, }
  Peking -&amp;gt; {London, Tokyo, }
  Tokyo -&amp;gt; {Peking, }
Model[The Connector Problem], 13 Solutions, MINIMIZE cost = 12154, Resolution time 0.416s, Time to best solution 0.389s, 704 Nodes (1,692.0 n/s), 1383 Backtracks, 0 Backjumps, 679 Fails, 0 Restarts
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;a-better-search-strategy&#34;&gt;A better search strategy&lt;/h2&gt;
&lt;p&gt;It is possible to give the solver hints to better explore the search space.
This is done by defining a search strategy. In our case, we want to select first edges associated to small distance.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.chocosolver.solver.search.strategy.strategy.GraphCostBasedSearch;
// ...


slv.reset(); // required to run the resolution twice
GraphCostBasedSearch mainSearch = new GraphCostBasedSearch(graph, distances);
mainSearch.configure(GraphCostBasedSearch.MIN_COST);
slv.setSearch(mainSearch);
while (slv.solve()){
    System.out.printf(&amp;quot;Spanning tree of cost %d\n&amp;quot;, totalCost.getValue());
    printGLB();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which results in:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Model[The Connector Problem], 1 Solutions, MINIMIZE cost = 12154, Resolution time 0.002s, Time to best solution 0.002s, 6 Nodes (2,717.0 n/s), 0 Backtracks, 0 Backjumps, 0 Fails, 0 Restarts
Spanning tree of cost 12154
Lower bound of G:
  London -&amp;gt; {New York, Paris, Peking, }
  Mexico City -&amp;gt; {New York, }
  New York -&amp;gt; {London, Mexico City, }
  Paris -&amp;gt; {London, }
  Peking -&amp;gt; {London, Tokyo, }
  Tokyo -&amp;gt; {Peking, }
Model[The Connector Problem], 1 Solutions, MINIMIZE cost = 12154, Resolution time 0.077s, Time to best solution 0.002s, 506 Nodes (6,532.8 n/s), 1011 Backtracks, 0 Backjumps, 505 Fails, 0 Restarts
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;the-entire-code&#34;&gt;The entire code&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
String[] cities = new String[]{
  &amp;quot;London&amp;quot;, &amp;quot;Mexico City&amp;quot;, &amp;quot;New York&amp;quot;, &amp;quot;Paris&amp;quot;, &amp;quot;Peking&amp;quot;, &amp;quot;Tokyo&amp;quot;
};

int[][] distances = 
{
  {0, 5558, 3469, 214, 5074, 5959},   // L
  {5558, 0, 2090, 5725, 7753, 7035},  // MC
  {3469, 2090, 0, 3636, 6844, 6757},  // NY
  {214, 5725, 3636, 0, 5120, 6053},   // Pa
  {5074, 7753, 6844, 5120, 0, 1307},  // Pe
  {5959, 7035, 6757, 6053, 1307, 0},  // T
};


Model cop = new Model(&amp;quot;The Connector Problem&amp;quot;);

UndirectedGraph GLB = new UndirectedGraph(cop, cities.length, SetType.BITSET, true);
UndirectedGraph GUB = new UndirectedGraph(cop, cities.length, SetType.BITSET, true);
for(int i = 0; i &amp;lt; cities.length; i++){
  for(int j = i+1; j &amp;lt; cities.length; j++){
      GUB.addEdge(i, j);   
  }  
}
UndirectedGraphVar graph = cop.graphVar(&amp;quot;G&amp;quot;, GLB, GUB);

IntVar[] degrees = cop.intVarArray(&amp;quot;degree&amp;quot;, cities.length, 0, 2);
cop.degrees(graph, degrees).post();

IntVar totalCost = cop.intVar(&amp;quot;cost&amp;quot;, 0, 6*99_999);
cop.setObjective(Model.MINIMIZE, totalCost);

cop.dcmst(graph,degrees,totalCost,distances,0).post();

Solver slv = cop.getSolver();

GraphCostBasedSearch mainSearch = new GraphCostBasedSearch(graph, distances);
mainSearch.configure(GraphCostBasedSearch.MIN_COST);
slv.setSearch(mainSearch);

slv.showShortStatistics();
while (slv.solve()){
    System.out.printf(&amp;quot;Spanning tree of cost %d\n&amp;quot;, totalCost.getValue());
    printGLB();
}
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Tutos: The keysort example</title>
      <link>https://choco-solver.org/tutos/other-examples/the-keysort-example/</link>
      <pubDate>Thu, 01 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://choco-solver.org/tutos/other-examples/the-keysort-example/</guid>
      <description>
        
        
        &lt;p&gt;In this example, we are going to see how to use the &lt;code&gt;StableKeysort&lt;/code&gt; constraint.
The &lt;code&gt;StableKeysort(L,P,S,k)&lt;/code&gt; provides a &lt;em&gt;view&lt;/em&gt; $S$ of an array of variables $L$ in which those variables are sorted using a stable multi-criteria sort on the first k keys.
Hence, it eases the expression of constraints on both the &lt;em&gt;sorted&lt;/em&gt; side of the problem.&lt;/p&gt;
&lt;p&gt;❗ &lt;em&gt;This model was developed with Choco-solver v.4.10.11&lt;/em&gt; ❗&lt;/p&gt;
&lt;h2 id=&#34;a-scheduling-problem&#34;&gt;A scheduling problem&lt;/h2&gt;
&lt;p&gt;Consider a task scheduling problem, consisting of 10 tasks fixed in time, to be executed in a given day.
Any task is either easy or hard.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int[] start_dates = {[6, 18, 2, 14, 2, 7, 0, 15, 7, 17]};
int[] durations = {[1, 2, 2, 1, 2, 1, 2, 1, 1, 1]};
int[] difficulties = {[1, 0, 0, 1, 0, 0, 0, 1, 1, 1]};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The team of workers consists of five people: three beginners and two experts. An expert can perform tasks of any difficulty and can work up to 9 hours a day.
A beginner can only do easy tasks and cannot work more than 6 hours a day.&lt;/p&gt;
&lt;p&gt;The aim is to assign each task to a worker while respecting the working time of each individual.&lt;/p&gt;
&lt;h3 id=&#34;imports&#34;&gt;Imports&lt;/h3&gt;
&lt;p&gt;First, let&amp;rsquo;s import the needed classes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.variables.BoolVar;
import org.chocosolver.solver.variables.IntVar;

import java.util.Arrays;
import java.util.stream.IntStream;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And create an instance of the &lt;code&gt;Model&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Model model = new Model(&amp;quot;Scheduling&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;one-worker-per-task&#34;&gt;One worker per task&lt;/h3&gt;
&lt;p&gt;For convenience, we consider that beginners are assigned to a value in $[0,2]$ and experts in $[3,4]$.&lt;/p&gt;
&lt;p&gt;Then, we can define the tasks, from the inputs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntVar[] starts = IntStream.range(0, n)
                    .mapToObj(i -&amp;gt; model.intVar(&amp;quot;S_&amp;quot; + i, start_dates[i])).toArray(IntVar[]::new);
IntVar[] durs = IntStream.range(0, n)
                    .mapToObj(i -&amp;gt; model.intVar(&amp;quot;D_&amp;quot; + i, durations[i]))
                    .toArray(IntVar[]::new);
IntVar[] ends = IntStream.range(0, n)
                    .mapToObj(i -&amp;gt; model.intVar(&amp;quot;E_&amp;quot; + i, start_dates[i] + durations[i]))
                    .toArray(IntVar[]::new);
IntVar[] users = IntStream.range(0, n)
                    .mapToObj(i -&amp;gt; model.intVar(&amp;quot;U_&amp;quot; + i, difficulties[i] == 0 ? 0 : 3, 4))
                    .toArray(IntVar[]::new); // 0 -&amp;gt; 2 : beginners, 3-4 : experts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;starts&lt;/code&gt;, &lt;code&gt;durs&lt;/code&gt; and &lt;code&gt;ends&lt;/code&gt; variables are defined as constants, only the &lt;code&gt;users&lt;/code&gt; are to be defined.
The domain of each variable that represents the user that does the task is adapted to the difficulty. Indeed, a difficult task cannot be done by a beginner, whereas an expert can do any type of task.&lt;/p&gt;
&lt;p&gt;We declare a &lt;code&gt;DiffN&lt;/code&gt; constraint to ensure that a worker cannot process two tasks at a time.
The &lt;code&gt;DiffN&lt;/code&gt; constraint holds if no two pairs of &lt;em&gt;rectangles&lt;/em&gt; overlap in all dimensions.
A rectangle is a two-dimension object, defined by an origin and a length on each dimension.&lt;br&gt;
Here, the x-axis will indicate the time and the y-axis the resources.
So, a task is a rectangle whose the starting time and the user are the origins and the duration and the value $1$ are the lengths.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;model.diffN(
        starts, users, // origins
        durs, IntStream.range(0, n).mapToObj(i -&amp;gt; model.intVar(1)).toArray(IntVar[]::new), // lengths
        true // additional filtering based on cumulative reasoning
).post();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;redundant-constraints&#34;&gt;Redundant constraints&lt;/h4&gt;
&lt;p&gt;In our example, since starting times and durations are fixed, it is possible to analyze the tasks in order to detect tasks that overlap in time and thus must be executed by different users.
Some inequality constraints can be added.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BiPredicate&amp;lt;Integer, Integer&amp;gt; overlap = (i, j) -&amp;gt;
        (start_dates[j] &amp;lt;= start_dates[i] &amp;amp;&amp;amp; start_dates[i] &amp;lt; start_dates[j] + durations[j])
                || (start_dates[i] &amp;lt;= start_dates[j] &amp;amp;&amp;amp; start_dates[j] &amp;lt; start_dates[i] + durations[i]);
for (int i = 0; i &amp;lt; n; i++) {
    for (int j = i + 1; j &amp;lt; n; j++) {
        if (overlap.test(i, j)) {
            System.out.printf(&amp;quot;[%d,%d] ov [%d,%d]\n&amp;quot;,
                    start_dates[i], start_dates[i] + durations[i],
                    start_dates[j], start_dates[j] + durations[j]);
            users[i].ne(users[j]).post();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, only two pairs of tasks overlap in time, so posting $\ne$ constraints is sufficient.
But, in more complex cases, it would be worthwhile to detect clique of inequalities and post &lt;code&gt;AllDifferent&lt;/code&gt; constraints.&lt;/p&gt;
&lt;h3 id=&#34;a-sorted-view-of-the-world&#34;&gt;A sorted view of the world&lt;/h3&gt;
&lt;p&gt;Now that we have ensured that each task is performed by a single worker, we must ensure that everyone&amp;rsquo;s working time is respected.
However, with the variables present, this is a relatively complicated exercise.&lt;/p&gt;
&lt;p&gt;This is where the &lt;code&gt;StableKeysort&lt;/code&gt; constraint comes in.&lt;/p&gt;
&lt;p&gt;Description from &lt;em&gt;Beldiceanu et al. (2015) A Modelling Pearl with Sortedness Constraints. GCAI 2015, Tbilisi, Georgia.&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given two lists of variables $L$ and $S$ and an $k$ an integer, this constraint holds if and
only if the list $S$ of variables form a rearrangement of $L$ that
is stably sorted by nondecreasing lexicographical order on the first k positions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We already have the variables forming $L$ (namely, &lt;code&gt;starts&lt;/code&gt;, &lt;code&gt;durations&lt;/code&gt;, &lt;code&gt;ends&lt;/code&gt; and &lt;code&gt;users&lt;/code&gt;), so we need to introduce variables representing $S$.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntVar[] sortedStarts = model.intVarArray(&amp;quot;SS&amp;quot;, n, 0, 23);
IntVar[] sortedDurs = model.intVarArray(&amp;quot;SD&amp;quot;, n, 1, 3);
IntVar[] sortedEnds = model.intVarArray(&amp;quot;SE&amp;quot;, n, 1, 24);
IntVar[] sortedUsers = model.intVarArray(&amp;quot;SU&amp;quot;, n, 0, 4);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The constraint signature includes an optional array of permutation variables. We will declare it to simplify the display of solutions, but it is sometimes convenient to have access to it to constrain the sort.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;IntVar[] permutations = model.intVarArray(&amp;quot;P&amp;quot;, n, 1, n);
model.keySort(
        IntStream.range(0, n).mapToObj(i -&amp;gt; new IntVar[]{users[i], starts[i], durs[i], ends[i]}).toArray(IntVar[][]::new),
        permutations,
        IntStream.range(0, n).mapToObj(i -&amp;gt; new IntVar[]{sortedUsers[i], sortedStarts[i], sortedDurs[i], sortedEnds[i]}).toArray(IntVar[][]::new),
        2
).post();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We specify 2 as the last parameter, indicating that the sorting only applies to &lt;code&gt;users&lt;/code&gt; then &lt;code&gt;starts&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We now have access to the tasks of each worker, sorted by increasing start. In fact, we do not have this information directly, however, the way the variables are ordered will allow us to easily extract this information.
In order to do this, we will first use refine equality constraints, indicating - when false - user changes. Such Boolean variables are named &lt;code&gt;y&lt;/code&gt; in the following.
The mathematical expression of these constraints is as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$y_0  = false $&lt;/li&gt;
&lt;li&gt;$ \forall i \in [1,n-1], y_i \iff (sU_{i-1} = sU_{i})$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Once these changes are known, it is possible to calculate the working time of each worker incrementally.
The working times depend on the durations of the tasks of a worker and the time elapsed between two tasks of the same worker.&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;$w_0 = sD_0$&lt;/li&gt;
&lt;li&gt;$\forall i \in [1,n-1], w_i = sD_i + y_i \times (sS_i - sE_{i-1})$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now that the working time are valuated, they can be bounded.
If the worker is a beginner, its working time may not exceed 6 hours, 9 hours otherwise.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;BoolVar[] y = model.boolVarArray(n);
IntVar[] w = new IntVar[n];
for (int i = 0; i &amp;lt; n; i++) {
    if (i == 0) {
        y[i].eq(0).post();
        w[i] = sortedDurs[i];
    } else {
        model.reifyXeqY(sortedUsers[i - 1], sortedUsers[i], y[i]);
        w[i] = sortedDurs[i].add(y[i].ift(w[i - 1].add(sortedStarts[i].sub(sortedEnds[i - 1])), 0)).intVar();
    }
    w[i].le(sortedUsers[i].lt(EXPERT).ift(beginnerWorkingTime, expertWorkingTime)).post();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All that remains is to define a research strategy.
It is optional but since only the users are to be found, we can restrict the decision variables to this set.&lt;/p&gt;
&lt;h3 id=&#34;solving&#34;&gt;Solving&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Solver solver = model.getSolver();                 
solver.printShortFeatures();                       
solver.setSearch(Search.inputOrderLBSearch(users));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We look for the first solution and print it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (solver.solve()) {                                                                             
    System.out.printf(&amp;quot;\nSolution #%d\n&amp;quot;, solver.getSolutionCount());                             
    for (int i = 0; i &amp;lt; n; i++) {                                                                 
        System.out.printf(&amp;quot;\tTask #%d [%d,%d] by user #%d (%s)\n&amp;quot;,                                
                i + 1, starts[i].getValue(), ends[i].getValue(), users[i].getValue(),             
                users[i].getValue() &amp;lt; EXPERT ? &amp;quot;B&amp;quot; : &amp;quot;E&amp;quot;);                                        
    }                                                                                             
    System.out.print(&amp;quot;In sorted world:\n&amp;quot;);                                                       
    for (int i = 0; i &amp;lt; n; i++) {                                                                 
        if (i == 0 || sortedUsers[i - 1].getValue() != sortedUsers[i].getValue()) {               
            System.out.printf(&amp;quot;\tUser #%d (%s):\n&amp;quot;, sortedUsers[i].getValue(),                    
                    sortedUsers[i].getValue() &amp;lt; EXPERT ? &amp;quot;B&amp;quot; : &amp;quot;E&amp;quot;);                              
        }       
        System.out.printf(&amp;quot;\t\tTask #%d [%d,%d]\n&amp;quot;,                                               
                permutations[i].getValue(), sortedStarts[i].getValue(), sortedEnds[i].getValue());
        if (i == n - 1 || sortedUsers[i].getValue() != sortedUsers[i + 1].getValue()) {           
            System.out.printf(&amp;quot;\t--&amp;gt; working time : %d\n&amp;quot;, w[i].getValue());                      
        }                           
    }           
    solution = true;                                                          
}                                                                                                 
solver.printShortStatistics();                                                                    
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Model[keysort], 250 variables, 127 constraints, building time: 0,264s, w/o user-defined search strategy, w/o complementary search strategy

Solution #1
  Task #1 [6,7] by user #3 (E)
  Task #2 [18,20] by user #0 (B)
  Task #3 [2,4] by user #1 (B)
  Task #4 [14,15] by user #3 (E)
  Task #5 [2,4] by user #2 (B)
  Task #6 [7,8] by user #1 (B)
  Task #7 [0,2] by user #2 (B)
  Task #8 [15,16] by user #4 (E)
  Task #9 [7,8] by user #3 (E)
  Task #10 [17,18] by user #4 (E)
In sorted world:
  User #0 (B):
    Task #2 [18,20]
  --&amp;gt; working time : 2
  User #1 (B):
    Task #3 [2,4]
    Task #6 [7,8]
  --&amp;gt; working time : 6
  User #2 (B):
    Task #7 [0,2]
    Task #5 [2,4]
  --&amp;gt; working time : 4
  User #3 (E):
    Task #1 [6,7]
    Task #9 [7,8]
    Task #4 [14,15]
  --&amp;gt; working time : 9
  User #4 (E):
    Task #8 [15,16]
    Task #10 [17,18]
  --&amp;gt; working time : 3
Model[keysort], 1 Solutions, Resolution time 0,244s, 105 Nodes (431,2 n/s), 186 Backtracks, 0 Backjumps, 96 Fails, 0 Restarts  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We have seen how the &lt;code&gt;StableKeysort&lt;/code&gt; constraint can be useful to have a second representation of a state. It then becomes relatively simple to constrain each of the views. However, this requires the use of reification constraints to determine when a user is changed or, for a user, when tasks are changed.
The use of this constraint is not trivial and requires care but it offers great flexibility and strong expressive power.&lt;/p&gt;
&lt;h2 id=&#34;all-together&#34;&gt;All together&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int EXPERT = 3;
int beginnerWorkingTime = 6;
int expertWorkingTime = 9;
Model model = new Model(&amp;quot;keysort&amp;quot;);
int n = 10;
int[] start_dates = IntStream.range(0, n).map(i -&amp;gt; rnd.nextInt(24)).toArray();
int[] durations = IntStream.range(0, n).map(i -&amp;gt; 1 + rnd.nextInt(2)).toArray();
int[] difficulties = IntStream.range(0, n).map(i -&amp;gt; rnd.nextInt(2)).toArray(); // 0: easy, 1: difficult

System.out.printf(&amp;quot;int[] start_dates = {%s};\n&amp;quot;, Arrays.toString(start_dates));
System.out.printf(&amp;quot;int[] durations = {%s};\n&amp;quot;, Arrays.toString(durations));
System.out.printf(&amp;quot;int[] difficulties = {%s};\n&amp;quot;, Arrays.toString(difficulties));

// Where the tasks are not ordered
IntVar[] starts = IntStream.range(0, n).mapToObj(i -&amp;gt; model.intVar(&amp;quot;S_&amp;quot; + i, start_dates[i])).toArray(IntVar[]::new);
IntVar[] durs = IntStream.range(0, n).mapToObj(i -&amp;gt; model.intVar(&amp;quot;D_&amp;quot; + i, durations[i])).toArray(IntVar[]::new);
IntVar[] ends = IntStream.range(0, n).mapToObj(i -&amp;gt; model.intVar(&amp;quot;E_&amp;quot; + i, start_dates[i] + durations[i])).toArray(IntVar[]::new);
IntVar[] users = IntStream.range(0, n) 
        .mapToObj(i -&amp;gt; model.intVar(&amp;quot;U_&amp;quot; + i,
                difficulties[i] == 0 ? 0 : 3, 4)) 
        .toArray(IntVar[]::new); // 0 -&amp;gt; 2 : beginners, 3-4 : experts

model.diffN(
        starts, users,
        durs, IntStream.range(0, n).mapToObj(i -&amp;gt; model.intVar(1)).toArray(IntVar[]::new),
        true
).post();

// Where (views of) the tasks are ordered by resources, then by starting time
IntVar[] sortedStarts = model.intVarArray(&amp;quot;SS&amp;quot;, n, 0, 23);
IntVar[] sortedDurs = model.intVarArray(&amp;quot;SD&amp;quot;, n, 1, 3);
IntVar[] sortedEnds = model.intVarArray(&amp;quot;SE&amp;quot;, n, 1, 24);
IntVar[] sortedUsers = model.intVarArray(&amp;quot;SU&amp;quot;, n, 0, 4);

// Ordered view of the tasks
IntVar[] permutations = model.intVarArray(&amp;quot;P&amp;quot;, n, 1, n);
model.keySort(
        IntStream.range(0, n).mapToObj(i -&amp;gt; new IntVar[]{users[i], starts[i], durs[i], ends[i]}).toArray(IntVar[][]::new),
        permutations,
        IntStream.range(0, n).mapToObj(i -&amp;gt; new IntVar[]{sortedUsers[i], sortedStarts[i], sortedDurs[i], sortedEnds[i]}).toArray(IntVar[][]::new),
        3
).post();

// In the sorted side
BoolVar[] y = model.boolVarArray(&amp;quot;shift&amp;quot;, n); // Boolean variable : y_i = (u&#39;_(i-1) == u_i)
IntVar[] w = new IntVar[n];
for (int i = 0; i &amp;lt; n; i++) {
    if (i == 0) {
        y[i].eq(0).post();
        w[i] = sortedDurs[i];
    } else {
        model.reifyXeqY(sortedUsers[i - 1], sortedUsers[i], y[i]);
        w[i] = sortedDurs[i].add(y[i].ift(w[i - 1].add(sortedStarts[i].sub(sortedEnds[i - 1])), 0)).intVar();
    }
    w[i].le(sortedUsers[i].lt(EXPERT).ift(beginnerWorkingTime, expertWorkingTime)).post();
}

// Redundant constraints
BiPredicate&amp;lt;Integer, Integer&amp;gt; overlap = (i, j) -&amp;gt;
        (start_dates[j] &amp;lt;= start_dates[i] &amp;amp;&amp;amp; start_dates[i] &amp;lt; start_dates[j] + durations[j])
                || (start_dates[i] &amp;lt;= start_dates[j] &amp;amp;&amp;amp; start_dates[j] &amp;lt; start_dates[i] + durations[i]);
for (int i = 0; i &amp;lt; n; i++) {
    for (int j = i + 1; j &amp;lt; n; j++) {
        if (overlap.test(i, j)) {
            System.out.printf(&amp;quot;[%d,%d] ov [%d,%d]\n&amp;quot;,
                    start_dates[i], start_dates[i] + durations[i],
                    start_dates[j], start_dates[j] + durations[j]);
            users[i].ne(users[j]).post();
        }
    }
}
Solver solver = model.getSolver();
solver.printShortFeatures();
solver.setSearch(Search.inputOrderLBSearch(users));
if (solver.solve()) {
    System.out.printf(&amp;quot;\nSolution #%d\n&amp;quot;, solver.getSolutionCount());
    for (int i = 0; i &amp;lt; n; i++) {
        System.out.printf(&amp;quot;\tTask #%d [%d,%d] by user #%d (%s)\n&amp;quot;,
                i + 1, starts[i].getValue(), ends[i].getValue(), users[i].getValue(),
                users[i].getValue() &amp;lt; EXPERT ? &amp;quot;B&amp;quot; : &amp;quot;E&amp;quot;);
    }
    System.out.print(&amp;quot;In sorted world:\n&amp;quot;);
    for (int i = 0; i &amp;lt; n; i++) {
        if (i == 0 || sortedUsers[i - 1].getValue() != sortedUsers[i].getValue()) {
            System.out.printf(&amp;quot;\tUser #%d (%s):\n&amp;quot;, sortedUsers[i].getValue(),
                    sortedUsers[i].getValue() &amp;lt; EXPERT ? &amp;quot;B&amp;quot; : &amp;quot;E&amp;quot;);
        }
        System.out.printf(&amp;quot;\t\tTask #%d [%d,%d]\n&amp;quot;,
                permutations[i].getValue(), sortedStarts[i].getValue(), sortedEnds[i].getValue());
        if (i == n - 1 || sortedUsers[i].getValue() != sortedUsers[i + 1].getValue()) {
            System.out.printf(&amp;quot;\t--&amp;gt; working time : %d\n&amp;quot;, w[i].getValue());
        }
    }
    solution = true;
}
solver.printShortStatistics();
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
    <item>
      <title>Tutos: The knapsack problem</title>
      <link>https://choco-solver.org/tutos/other-examples/the_knapsack_problem/</link>
      <pubDate>Fri, 23 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://choco-solver.org/tutos/other-examples/the_knapsack_problem/</guid>
      <description>
        
        
        &lt;p&gt;&lt;em&gt;This file can be downloaded as a &lt;a href=&#34;https://jupyter.org/&#34;&gt;jupyter notebook&lt;/a&gt; and executed with a &lt;a href=&#34;https://github.com/SpencerPark/IJava&#34;&gt;Java kernel&lt;/a&gt;. The next cell is then used to add the dependency to choco and can be ignored otherwise.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://choco-solver.org/notebooks/content/en/tutos/Other%20examples/The_knapsack_problem.ipynb&#34;&gt;&amp;raquo; ipynb &amp;laquo;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;// Add maven dependencies at runtime 
%maven org.choco-solver:choco-solver:4.10.13
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Knapsack_problem&#34;&gt;Wikipedia&lt;/a&gt;:&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a set of items, each with a weight and a value, determine the count of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible. It derives its name from the problem faced by someone who is constrained by a fixed-size knapsack and must fill it with the most useful items.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First manage imports.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.exception.ContradictionException;
import org.chocosolver.solver.variables.IntVar;

import java.util.Arrays;

import static org.chocosolver.solver.search.strategy.Search.inputOrderLBSearch;
import static org.chocosolver.solver.search.strategy.Search.inputOrderUBSearch;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;input-data&#34;&gt;Input data&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;int n = 10; // number of different items
int W = 67; // a maximum weight capacity 
int[] w = new int[]{23, 26,20,18,32, 27, 29, 26, 30, 27}; // weight of items
int[] v = new int[]{505, 352, 458, 220, 354, 414, 498, 545, 473, 543}; // value of items
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;the-model&#34;&gt;The model&lt;/h2&gt;
&lt;p&gt;Then, we can start modelling the problem with choco.
The first step is to defined a &lt;code&gt;Model&lt;/code&gt; instance.
It is required to declare and store the variables and the constraints.
For convenience, an instance can be declared with a name.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;Model model = new Model(&amp;quot;Knapsack&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each object, a variable is declared to count the number of times it appears in the knapsack.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;IntVar[] items = new IntVar[n];
for (int i = 0; i &amp;lt; n; i++) {
    items[i] = model.intVar(&amp;quot;item_&amp;quot; + (i + 1), 0, (int) Math.ceil(W*1. / w[i]));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The paramaters are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the prefix for setting the variables&amp;rsquo; name,&lt;/li&gt;
&lt;li&gt;the lower bound and the upper bound of each variable.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Remark:&lt;/strong&gt;
&lt;em&gt;To model 0-1 knapsack problem, the upper bound of each variable must be set to $1$.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The problem is to maximize the sum of the values of the items in the knapsack.
This amount is maintained in a variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;IntVar value = model.intVar(&amp;quot;value&amp;quot;, 0, Arrays.stream(v).max().orElse(999) * n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The sum of the weights is less than or equal to the knapsack&amp;rsquo;s capacity:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;IntVar weight = model.intVar(&amp;quot;weight&amp;quot;, 0, W);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All variables are now declared, the &lt;code&gt;knapsack&lt;/code&gt; constraint can be declared:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;model.knapsack(items, weight, value, w, v).post();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;value&lt;/code&gt; variable has to be maximized:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;model.setObjective(Model.MAXIMIZE, value);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;finding-the-optimal-solution&#34;&gt;Finding the optimal solution&lt;/h2&gt;
&lt;p&gt;Now that the model is ready, the solving step can be set up.
Here we define a top-down maximization:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;Solver solver = model.getSolver();
solver.setSearch(
    inputOrderUBSearch(value), 
    inputOrderLBSearch(items));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;rsquo;s execute the solving:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Java&#34;&gt;while (solver.solve()) {
    System.out.printf(&amp;quot;Knapsack -- %d items\n&amp;quot;, n);
    System.out.println(&amp;quot;\tItem: Count&amp;quot;);
    for (int i = 0; i &amp;lt; items.length; i++) {
        System.out.printf(&amp;quot;\tItem #%d: %d\n&amp;quot;, (i+1), items[i].getValue());
    }
    System.out.printf(&amp;quot;\n\tWeight: %d\n&amp;quot;, weight.getValue());
    System.out.printf(&amp;quot;\n\tValue: %d\n&amp;quot;, value.getValue());
}
solver.reset(); // to solve the model several times
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Knapsack -- 10 items
	Item: Count
	Item #1: 2
	Item #2: 0
	Item #3: 1
	Item #4: 0
	Item #5: 0
	Item #6: 0
	Item #7: 0
	Item #8: 0
	Item #9: 0
	Item #10: 0

	Weight: 66

	Value: 1468
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The optimal value for this instance of the knapsack problem is $1468$ with a total weight of $66$.&lt;/p&gt;
&lt;p&gt;When turned to a 0-1 knapsack problem, the optimal value is $1270$ with a total weight of $67$.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Tutos: Project Euler, Problem 103</title>
      <link>https://choco-solver.org/tutos/other-examples/euler-103/</link>
      <pubDate>Tue, 02 Feb 2021 09:21:16 +0100</pubDate>
      
      <guid>https://choco-solver.org/tutos/other-examples/euler-103/</guid>
      <description>
        
        
        &lt;p&gt;Thanks to &lt;a href=&#34;https://www.univ-nantes.fr/mathieu-vavrille&#34;&gt;Mathieu Vavrille&lt;/a&gt; for his modelling of &lt;a href=&#34;https://projecteuler.net/problem=103&#34;&gt;problem 103 of the Euler project&lt;/a&gt;, &amp;ldquo;Special subset sums: optimum&amp;rdquo;, using Constraint Programming and Choco.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Euler {

  public static void main(final String[] args) {
    System.out.println(euler103());
  }

  /** Euler 103, Special subset sums */
  private static String euler103() {
    int n = 7;
    int bound = 40;
    List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt; allPartitions = partitions(n-1); // Enumerates all the partitions of {0, ..., n-1}
    Model model = new Model();
    IntVar[] mainSet = model.intVarArray(&amp;quot;set&amp;quot;, n, 0, 100); // Numbers in the set
    for (int i = 0; i &amp;lt; n-1; i++) {
      mainSet[i].lt(mainSet[i+1]).post(); // Order the numbers in the set
    }
    IntVar[] partitionSums = model.intVarArray(&amp;quot;partition&amp;quot;, allPartitions.size(), 0, n*bound); // Create a variable representing the sum of each subset
    for (int i = 0; i &amp;lt; partitionSums.length; i++)
      model.sum(allPartitions.get(i).stream()
                .map(id -&amp;gt; mainSet[id])
                .toArray(IntVar[]::new), &amp;quot;=&amp;quot;, partitionSums[i]).post();
  for (int i = 0; i &amp;lt; allPartitions.size(); i++)
      for (int j = i+1; j &amp;lt; allPartitions.size(); j++)
        if (Collections.disjoint(allPartitions.get(i), allPartitions.get(j))) { // Enforce the constraint for distinct subsets
          if (allPartitions.get(i).size() &amp;gt; allPartitions.get(j).size())
            partitionSums[i].gt(partitionSums[j]).post();
          else if (allPartitions.get(i).size() == allPartitions.get(j).size())
            partitionSums[i].ne(partitionSums[j]).post();
          else if (allPartitions.get(i).size() &amp;lt; allPartitions.get(j).size())
            partitionSums[i].lt(partitionSums[j]).post();
        }
  model.setObjective(false, partitionSums[partitionSums.length-1]); // Objective is the sum of the variables in the set
  Solver solver = model.getSolver();
  String result = &amp;quot;&amp;quot;;
  while (solver.solve()) { // Solve
    result = Arrays.stream(mainSet)
      .map(var -&amp;gt; Integer.toString(var.getValue()))
      .collect(Collectors.joining());
  }
  return result;
  }
  
  private static List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt; partitions(final int n) {
    if (n == 0) {
      List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt; parts = new ArrayList&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt;();
      parts.add(new HashSet&amp;lt;Integer&amp;gt;());
      parts.add(Set.of(0));
      return parts;
    }
    List&amp;lt;Set&amp;lt;Integer&amp;gt;&amp;gt; smaller = partitions(n-1);
    for (int i = 0; i &amp;lt; 1&amp;lt;&amp;lt;n; i++) {
      Set&amp;lt;Integer&amp;gt; currentAdded = new HashSet&amp;lt;Integer&amp;gt;(smaller.get(i));
      currentAdded.add(n);
      smaller.add(currentAdded);
    }
    return smaller;
  }
  
}
&lt;/code&gt;&lt;/pre&gt;

      </description>
    </item>
    
  </channel>
</rss>
